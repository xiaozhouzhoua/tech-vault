[![License](https://img.shields.io/badge/License-Apache_2.0-blue.svg)](https://opensource.org/licenses/Apache-2.0)
[![PRs Welcome](https://img.shields.io/badge/PRs-welcome-brightgreen.svg?style=flat-square)](http://makeapullrequest.com)

# 技术宝库 🛠️ (中文版)

<p align="center">
  <img width="1000" src="./images/Tech-Vault.png">
</p>

## 关于

这是一个精心策划的技术工程问题和挑战的综合文档库，由进行过大量面试的经验丰富的工程师创建。该收藏包含流行且重要的工程问题，旨在评估候选人在各种技术领域的知识。

注意：来自外部参考资料的问题已在[参考文献](#参考文献)部分中正确注明出处。

## 目录

- [X] [愿景 🚀](#愿景)
- [X] [本仓库与其他仓库的不同之处 🌟](#本仓库与其他仓库的不同之处)
- [X] [贡献指南 🖊️](#贡献指南)
- [X] [DevOps 挑战](./devops-challenges/README.md)
- [X] [编程挑战](./coding-challenges/README.md)
- [X] [数据结构和算法挑战](./dsa-challenges/README.md)
- [X] [DevOps 🛠](#devops)
    - [Linux 🐧](#small_blue_diamond-linux)
    - [网络 🌐](#small_blue_diamond-网络)
    - [Git](#small_blue_diamond-git)
    - [AWS 🌩️](#small_blue_diamond-aws)
    - [Azure 🌩️](#small_blue_diamond-azure)
    - [Terraform 🏗️](#small_blue_diamond-terraform)
    - [Docker & K8s 🐳 🎻](#small_blue_docker--k8s)
    - [Ansible 🔧](#small_blue_diamond-ansible)
    - [CI/CD 🛠️](#small_blue_diamond-cicd)
    - [DevOps 方法论、实践和敏捷](#small_blue_diamond-devops-方法论实践--敏捷)
- [X] [系统设计 🍥](#系统设计)
    - [CDN 和缓存 ⚡](#small_blue_diamond-cdn--缓存)
    - [数据库 📊](#small_blue_diamond-数据库)
- [X] [软件工程](#软件工程)
    - [通用](#small_blue_diamond-通用)
    - [Golang](#small_blue_diamond-golang)
    - [Python](#small_blue_diamond-python)
    - [Java](#small_blue_diamond-java)
    - [JavaScript](#small_blue_diamond-javascript-tsnodejs)
- [X] [数据](#数据)
    - [数据建模和模式](#数据建模和模式)
    - [数据架构师](#数据架构师)
    - [数据工程](#数据工程)
    - [SQL](#sql)
    - [ETL 和数据管道](#etl-和数据管道)
- [X] [机器学习 🤖](#机器学习)
- [X] [网络安全和信息 🛡️](#网络安全--信息安全)
- [X] [人际交往能力](#人际--行为问题)
- [X] [参考文献](#参考文献)

## 愿景 🚀

对于没有技术背景或没有先前经验的人来说，进入技术领域可能具有挑战性。这就是为什么我们的团队创建了技术宝库——一个为技术和非技术专业人士准备技术面试的集中资源。

该项目由充满热情的工程师社区维护。我们欢迎您的贡献！请参阅我们的[贡献指南](./CONTRIBUTING.md)开始。

## 本仓库的不同之处 🌟

1. **真实面试问题** - 由工程师提出并被问到的实际问题（为清晰起见进行了适当的改写）
2. **基于场景的问题** - 反映实际面试情况的真实问题
3. **当前且相关** - 反映现代工程实践的最新主题
4. **专家维护** - 由各自领域的经验丰富的工程师持续更新
5. **实践挑战** - 模拟真实世界场景的实践 DevOps 挑战，用于动手学习
6. **交互式工具** - 用于练习课程的[随机问题生成器](./misc/README.md)
7. **CLI 访问** - [基于终端访问的技术宝库 CLI 工具](https://github.com/moabukar/tech-vault-cli)

## 贡献 🖊️

- 要贡献，请阅读我们的[贡献指南](CONTRIBUTING.md)。对于任何修复、更新或新添加的内容，请提交拉取请求（PR）。谢谢！

## DevOps 🛠

### :small_blue_diamond: Linux

<details>
<summary>什么是 Linux？UNIX 和 Linux 有什么区别？</summary>

Linux 是一个基于 UNIX 架构的开源操作系统。它由 Linus Torvalds 于 1991 年创建。另一方面，UNIX 是一个操作系统家族，于 1960 年代后期在贝尔实验室开发。UNIX 和 Linux 之间的主要区别是：

- **许可证：** UNIX 是专有的，而 Linux 是开源的，可以免费使用。
- **开发：** UNIX 由少数组织（如 IBM、Sun Microsystems 和 HP）开发，而 Linux 拥有广泛的社区驱动开发过程。
- **可移植性：** Linux 更具可移植性，可以在广泛的硬件上使用，而 UNIX 限于特定的硬件平台。
- **用户基础：** Linux 拥有更广泛的用户基础，包括个人计算机、服务器和嵌入式系统，而 UNIX 主要用于企业环境。
</details>

<details>
<summary>什么是 Linux 内核？</summary>

Linux 内核是 Linux 操作系统的核心组件。它负责管理系统的资源，提供硬件和软件之间的接口，并促进基本任务，如内存管理、进程调度和输入/输出（I/O）操作。
</details>

<details>
<summary>Linux 中的 inode 是什么？</summary>

Linux 中的 inode 是存储文件系统上文件重要信息的数据结构。Linux 文件系统中的每个文件或目录都有一个关联的 inode，包含元数据，如文件大小、权限、所有权、时间戳和文件数据块在磁盘上的位置。

当您创建文件或目录时，文件系统为其分配一个唯一的 inode 编号。inode 编号作为文件的标识符，允许文件系统访问 inode 的信息并相应地管理文件。

以下是 inode 存储内容的摘要：

- 文件类型（常规文件、目录、符号链接等）
- 文件权限（读、写、执行）
- 所有权（用户和组）
- 时间戳（创建、修改和访问时间）
- 文件大小
- 指向文件的硬链接数
- 文件数据块在磁盘上的位置

重要的是要注意，inode 不存储文件名或实际的文件数据。文件名存储在包含文件的目录中，该目录将名称与 inode 编号关联。实际文件数据存储在磁盘上单独的数据块中，inode 指向这些块。

inode 在管理 Linux 文件系统中的文件和目录方面起着至关重要的作用，提供了访问和操作文件元数据的有效方法。
</details>

<details>
<summary>解释 Linux 启动过程</summary>

Linux 启动过程包括几个阶段，这些阶段初始化系统并加载操作系统。以下是关键步骤的简要概述：

BIOS/UEFI：当计算机开机时，BIOS（基本输入/输出系统）或 UEFI（统一可扩展固件接口）执行初始硬件检查并定位启动设备。

引导加载程序：引导加载程序（例如 GRUB）从启动设备加载并向用户呈现可用的操作系统。然后它将 Linux 内核和初始 RAM 磁盘（initrd）加载到内存中。

内核初始化：Linux 内核初始化硬件，设置内存管理，启动基本进程，并挂载初始 RAM 磁盘，其中包含启动过程所需的基本驱动程序和工具。

根文件系统：内核将根文件系统从初始 RAM 磁盘切换到磁盘上的实际根分区，通常通过其 UUID 或设备名称（例如 /dev/sda1）识别。

Init 进程：第一个用户空间进程，称为 init（例如 Systemd、SysVinit 或 Upstart），启动并在启动过程和系统运行时管理系统服务和进程。

运行级别/目标：Init 进程初始化预定义的运行级别（SysVinit）或目标（Systemd），这决定了启动时要运行的服务和进程。

登录提示：一旦运行级别/目标中指定的所有服务和进程都已启动，系统显示登录提示，表示启动过程已完成，系统可供使用。
</details>

<details>
<summary>什么是僵尸进程？</summary>

僵尸进程，也称为终止进程，是一个已完成执行但仍保留在进程表中的进程。发生这种情况是因为父进程尚未读取子进程的退出状态，这是清理子进程资源并从进程表中删除其条目所必需的。

僵尸进程不消耗任何系统资源，除了进程表条目，其中包括进程 ID（PID）和退出状态。操作系统保留此信息，以便父进程最终可以检索退出状态并执行必要的清理。

有关僵尸进程的更多信息如下：

通常，行为良好的父进程将使用 wait() 或 waitpid() 系统调用来收集其子进程的退出状态。但是，如果父进程不这样做，无论是由于编程错误还是因为父进程仍在运行且尚未到达收集退出状态的时间点，子进程就会变成僵尸。

僵尸进程通常是无害的，但如果系统积累了大量僵尸进程，可能会耗尽可用的 PID 并阻止创建新进程。要解决此问题，应该修复父进程以正确处理其子进程的退出状态，或者如果父进程无响应或已终止，可能需要重新启动系统。
</details>

<details>
<summary>软链接和硬链接有什么区别？</summary>

软链接和硬链接是类 Unix 文件系统（如 Linux）中的两种文件链接类型。它们服务于不同的目的并具有不同的特征：

**软链接（符号链接）：**

- 软链接是一个单独的文件，通过存储其路径指向目标文件或目录。
- 如果目标文件被删除，软链接成为"悬空"链接，指向不存在的文件。
- 软链接可以跨不同文件系统和分区。
- 软链接可以链接到目录以及文件。
- 创建软链接时，目标文件的链接计数不会改变。
- 软链接具有与其目标文件不同的 inode 编号。

**硬链接：**

- 硬链接是对磁盘上数据的直接引用，与目标文件共享相同的 inode。
- 如果目标文件被删除，硬链接仍然指向数据，并且数据保持可访问状态，直到对其的所有硬链接都被删除。
- 硬链接只能在同一文件系统或分区内创建。
- 硬链接不能链接到目录，只能链接到文件。
- 创建硬链接时，目标文件的链接计数增加一。
- 硬链接与其目标文件具有相同的 inode 编号。

总之，软链接是一种更灵活但可靠性较低的链接类型，可以指向跨文件系统的文件或目录，而硬链接是一种更强大的链接，直接引用文件的数据，但限于同一文件系统且不能链接到目录。
</details>

<details>
<summary>什么是命名空间和 cgroups？</summary>

命名空间和 cgroups（控制组）是两个 Linux 内核功能，在实现进程隔离和资源管理方面起着至关重要的作用，特别是在像 Docker 这样的容器化技术中。

**命名空间：**

命名空间是一个功能，通过创建某些系统资源的单独实例来提供进程隔离，这些实例只能由同一命名空间内的进程访问。这种隔离有助于确保在一个命名空间中运行的进程不会干扰另一个命名空间中的进程。

有几种类型的命名空间，包括：

- PID 命名空间：隔离进程 ID，允许每个命名空间拥有自己的一组 PID。
- 挂载命名空间：隔离文件系统挂载点，因此每个命名空间都有自己的挂载树。
- 网络命名空间：隔离网络资源，为每个命名空间提供自己的网络堆栈，包括接口、路由和防火墙规则。
- IPC 命名空间：隔离进程间通信资源，防止一个命名空间中的进程与另一个命名空间中的进程通信。
- UTS 命名空间：隔离系统标识符，如主机名，允许每个命名空间拥有自己唯一的主机名。
- 用户命名空间：隔离用户和组 ID 映射，使每个命名空间能够拥有自己的一组用户和组 ID。

**Cgroups（控制组）：**

Cgroups 是一个内核功能，能够管理和限制一组进程的系统资源，如 CPU、内存和 I/O。Cgroups 有助于确保资源的公平分配，防止资源饥饿，并强制执行资源使用限制。cgroups 的一些关键功能包括：

- 资源限制：允许为一组进程设置资源使用限制，如最大 CPU 使用率、内存消耗和磁盘 I/O 带宽。
- 优先级：允许在不同 cgroup 之间设置资源分配优先级，有助于确保关键进程获得足够的资源。
- 统计：收集 cgroup 中进程的资源使用统计，可用于监控、分析和计费目的。
- 控制：提供启动、停止或冻结 cgroup 中进程的机制，允许更好地管理进程组。

组合在一起，命名空间和 cgroups 提供了构建和运行容器所需的隔离和资源管理能力，使多个容器能够在同一主机上共存，而不会相互干扰或消耗过多资源。
</details>

<details>
<summary>什么是符号链接？</summary>

符号链接，也称为软链接或 symlinks，是类 Unix 文件系统（如 Linux）中的一种文件链接类型。符号链接是一个特殊文件，通过存储其路径指向另一个文件或目录。符号链接作为目标文件或目录的引用，允许用户和应用程序通过链接访问目标。

符号链接在各种场景中都很有用，如创建快捷方式、链接到不同位置的文件或目录，或维护文件或目录的多个版本。符号链接的一些关键特征是：

符号链接可以指向文件或目录，并且可以跨不同文件系统和分区。
如果目标文件或目录被移动或删除，符号链接成为"悬空"链接，指向不存在的位置。
符号链接具有与其目标文件或目录不同的 inode 编号。
使用 ls 命令列出文件时，符号链接通常在文件权限的开头用"l"表示，并用箭头（->）指向目标文件或目录。

要在 Linux 中创建符号链接，可以使用 ln 命令的 -s 选项，后跟目标文件或目录和所需的符号链接名称：

```bash
ln -s 目标文件 符号链接名称

示例：

ln -s /path/to/original/file.txt link_to_file.txt

此命令创建一个名为 link_to_file.txt 的符号链接，指向位于 /path/to/original/file.txt 的文件。
```
</details>

<details>
<summary>Linux 中有哪些不同类型的权限？</summary>

在 Linux 中，文件和目录有三种主要类型的权限，这些权限决定了用户如何与它们交互。这些权限根据用户与文件或目录的关系分类：所有者、组和其他人（有时称为"世界"或"公众"）。三种类型的权限是：

读（r）：读权限允许用户查看文件的内容或列出目录的内容。对于文件，这意味着用户可以打开和读取文件。对于目录，用户可以查看该目录中文件和子目录的名称。

写（w）：写权限允许用户修改文件的内容或在目录内进行更改。对于文件，这意味着用户可以编辑、附加或删除文件的内容。对于目录，用户可以在该目录内创建、重命名或删除文件和子目录。请注意，删除或重命名目录中的文件需要对该目录本身具有写权限，而不是对单个文件。

执行（x）：执行权限允许用户将文件作为程序或脚本运行，或进入和访问目录。对于文件，这意味着如果文件是二进制可执行文件或具有适当解释器的脚本（例如 shell 脚本或 Python 脚本），用户可以执行该文件。对于目录，用户可以将其当前工作目录更改为该目录，并访问其中的文件和子目录。

这些权限通常使用字母（r、w、x）和破折号（-）的组合来表示，针对所有者、组和其他人三个类别。例如，权限字符串 -rwxr-xr-- 表示：

- 第一个字符 - 表示它是一个常规文件（d 表示目录）。
- 所有者具有读（r）、写（w）和执行（x）权限：rwx。
- 组具有读（r）和执行（x）权限，但没有写权限：r-x。
- 其他人只有读（r）权限：r--。

或者，权限也可以使用八进制表示法（基数为 8）表示，其中读、写和执行权限分别被分配值 4、2 和 1。权限然后用一个三位数表示，每个数字对应所有者、组和其他人。例如，权限字符串 -rwxr-xr-- 可以用八进制表示法表示为 754。
</details>

<details>
<summary>什么是交换空间？</summary>

交换空间是存储设备（如硬盘驱动器或 SSD）上的专用区域，用作计算机物理内存（RAM）的扩展。操作系统使用它来临时存储不适合 RAM 的数据，或者当系统由于高 RAM 利用率而经历内存压力时。

当操作系统需要比物理可用内存更多的内存时，它可以将最近最少使用或不重要的数据（称为页面）从 RAM 移动到交换空间。这个过程称为"分页"或"换出"。通过这样做，它为 RAM 中的更关键或频繁访问的数据腾出空间。如果再次需要换出的数据，操作系统会将其移回 RAM，可能在此过程中换出其他数据。这称为"换入"。

交换空间可以实现为专用交换分区或交换文件。在 Linux 中，您可以使用 swapon、swapoff 和 mkswap 等命令管理交换空间。要检查 Linux 系统上的当前交换空间使用情况，可以使用 free 或 swapon -s 命令。
</details>

<details>
<summary>Linux 中的 chmod、chown 和 chgrp 是什么？</summary>

**chmod**

chmod（更改模式）是用于更改文件或目录权限的命令。您可以为所有者、组和其他人设置读、写和执行权限。权限可以用八进制表示法（数字）或使用符号表示法（字母）表示。

示例：例如，要给所有者读、写和执行权限，给组读和执行权限，给其他人只读权限，您可以使用：
- 使用八进制表示法：`chmod 754 file.txt`
- 使用符号表示法：`chmod u=rwx,g=rx,o=r file.txt`

**chown**

chown（更改所有者）是用于更改文件或目录所有权的命令。您可以指定文件或目录的新所有者和可选的新组。

示例：例如，要将 file.txt 的所有者更改为用户 john，组更改为 developers，您可以使用：

`chown john:developers file.txt`

**chgrp**

chgrp（更改组）是用于更改文件或目录组分配的命令。您可以指定文件或目录的新组。

示例：例如，要将 file.txt 的组更改为 developers 组，您可以使用：

`chgrp developers file.txt`
</details>

<details>
<summary>什么是 cron 作业？</summary>

Cron 作业，也称为 cron 任务或简称 cron，是在类 Unix 操作系统（如 Linux）上以指定间隔自动运行的计划任务。术语"cron"来自希腊单词"chronos"，意思是"时间"。Cron 作业通常用于自动化重复性任务、执行系统维护、运行定期备份和其他类似活动。

Cron 作业由称为"cron"的守护进程管理，该守护进程在后台运行并执行计划任务。cron 作业的配置存储在一系列称为"crontabs"（"cron 表"的缩写）的文件中。系统上的每个用户都可以有自己的 crontab，还有一个系统范围的 crontab。

例如，每天凌晨 3:30 运行的 cron 作业在 crontab 中会有以下条目：

`30 3 * * * /path/to/command arg1 arg2`

要管理 cron 作业，您可以使用带有各种选项的 crontab 命令：

- crontab -l：列出当前用户的 cron 作业。
- crontab -e：使用默认文本编辑器编辑当前用户的 cron 作业。
- crontab -r：删除当前用户的 cron 作业。
- crontab -u USER：对指定用户的 cron 作业执行操作（列出、编辑或删除）（需要 root 权限）。
</details>

**命令（基础和高级）：**

<details>
<summary>chmod +x FILENAME 命令有什么作用？</summary>

chmod +x FILENAME 命令用于在 Linux 或类 Unix 系统中向文件添加执行权限。通过添加执行权限，您允许文件作为可执行文件或脚本运行，前提是它具有适当的格式和解释器（例如 shell 脚本、Python 脚本或编译的二进制文件）。+x 选项特别向所有者、组和其他人（所有用户）授予执行权限。

例如，如果您有一个名为 myscript.sh 的脚本，并且想使其可执行，您应该运行：

`chmod +x myscript.sh`
</details>

<details>
<summary>哪个命令将显示可用/已用内存？</summary>

free 命令用于显示有关可用和已用内存的信息。该命令提供关于总内存、已用内存、空闲内存、共享内存和可用内存的详细信息，以及交换空间使用情况。

要使用 free 命令，只需在终端中键入 free，后跟任何所需的选项。一些常见选项包括：

- -b：以字节显示内存使用情况。
- -k：以千字节显示内存使用情况（默认）。
- -m：以兆字节显示内存使用情况。
- -g：以千兆字节显示内存使用情况。
- -h：以人类可读格式显示内存使用情况，自动选择适当的单位（例如 B、K、M 或 G）。
- -t：显示包含物理内存总量和交换空间的一行。
- -s N：连续显示内存使用信息，每 N 秒更新一次。

例如，要以人类可读格式显示内存使用情况，您应该运行：

`free -h`
</details>

<details>
<summary>哪个命令将显示我当前所在的目录？</summary>

`pwd`
</details>

<details>
<summary>如何终止正在进行的进程？</summary>

`kill -9 PID`
</details>

<details>
<summary>编写显示所有 .yaml 文件包括每个文件权限的命令？</summary>

`find . -type f -name "*.yaml" -exec ls -l {} \;`
</details>

<details>
<summary>如何找到进程的状态？</summary>

`ps -p <PID>` >> 对于 1 个进程

`ps aux` >> 显示系统上所有正在运行的进程的详细列表
</details>

<details>
<summary>显示所有开放端口的命令是什么？</summary>

`netstat -tuln`
</details>

<details>
<summary>如何在 Linux 中找到正在运行的进程的进程 ID？</summary>

- `ps -ef | grep <进程名>`
- `ps -ef | grep chrome`
</details>

<details>
<summary>如何在 Linux 中找到包的依赖项？</summary>

基于 Debian（Ubuntu）：
- `apt depends <包名>`
- `apt-cache depends <包名>`

基于 Red Hat（Fedora、CentOS）：
- `dnf repoquery --requires <包名>`
</details>

**高级：**

<details>
<summary>Linux 上存在空闲内存吗？</summary>

在 Linux 系统上，"空闲内存"的概念可能有点微妙，因为 Linux 管理内存的方式。虽然"空闲内存"这个术语被广泛使用，但 Linux 使用复杂的内存管理系统，最大化利用可用内存以获得最佳性能。

在 Linux 中，空闲内存指的是当前未被任何活动进程使用或被系统缓存的内存。然而，这并不意味着内存完全未使用或浪费。Linux 通过利用可用内存进行磁盘缓存、缓冲和其他优化来提高系统性能，从而充分利用可用内存。

当使用 free 或 top 等工具检查内存使用情况时，您将看到几个与内存相关的指标，包括"空闲"、"已用"、"缓冲区"和"缓存"。这些指标代表内存使用的不同方面。
</details>

<details>
<summary>如何检查服务器是否宕机？</summary>

1) ping 命令是一个简单且广泛使用的工具，用于检查 Linux 系统和远程服务器之间的连接性

`ping <服务器地址>`

2) telnet 命令允许您建立到服务器特定端口的连接。通过尝试连接服务器的端口，您可以确定它是否已启动并接受连接

`telnet <服务器地址> <端口>`

3) 如果 telnet 命令在您的系统上不可用，您可以使用 nc（netcat），它提供类似的功能。

`nc -zv <服务器地址> <端口>`
</details>

<details>
<summary>/proc 里面有什么？</summary>

`/proc` 目录是一个虚拟文件系统，提供动态访问进程相关信息的接口。它包含各种文件和文件夹，提供有关正在运行的进程和系统配置的信息。

- 它在由其进程 ID（PID）标识的单独文件夹中保存有关每个正在运行的进程的详细信息。
- 它还提供系统范围的信息，如 CPU 详细信息、内存使用统计、网络相关数据和内核参数。
- /proc 的内容根据系统和正在运行的进程的当前状态动态变化。
</details>

<details>
<summary>系统上的进程无法再记录文件，我该怎么办？</summary>

- **检查文件权限**：确保进程具有写入日志文件或目录所需的权限。验证日志文件的所有权和权限，并确保它们可由与进程关联的用户或组写入。

- **验证可用磁盘空间**：磁盘空间不足会阻止进程写入日志文件。

- **重新启动进程**

- **检查日志文件大小限制**：某些进程对它们可以生成的日志文件的最大大小有限制。

- **检查文件系统或磁盘错误**：在相关文件系统上执行文件系统检查（fsck）或使用适当的工具检查磁盘错误。文件系统错误或磁盘问题有时会干扰文件写入。

- **验证日志记录配置**：确保正确指定了日志文件路径和其他设置。

- **检查系统级日志记录问题**：如果多个进程无法记录文件，则日志记录基础架构可能存在系统范围的问题。检查系统日志（例如 /var/log/syslog 或 /var/log/messages）中任何相关的错误消息或日志记录问题的迹象。
</details>

<details>
<summary>什么是 LILO？</summary>

- LILO，是"LInux LOader"的缩写，是在旧版 Linux 发行版中使用的引导加载程序。
- LILO 的主要功能是将 Linux 内核加载到内存中并启动引导过程。它向用户显示菜单，允许选择要启动的所需内核或操作系统（如果安装了多个操作系统）。
- LILO 将自身写入磁盘的主引导记录（MBR），覆盖现有的引导加载程序。
- 其配置文件（/etc/lilo.conf）指定 Linux 内核映像的位置和引导参数。
- LILO 在很大程度上已被其他引导加载程序取代，特别是 GRUB（Grand Unified Bootloader），它提供更高级的功能和灵活性。
- GRUB 已成为许多 Linux 发行版的默认引导加载程序。
</details>

<details>
<summary>Linux 中的系统调用是什么，它们是如何工作的？</summary>

- 系统调用是 Linux 中用户空间应用程序和内核之间的接口。
- 它们允许用户程序请求服务和访问操作系统资源。
- 用户程序使用特殊指令调用系统调用，触发从用户模式到内核模式的切换。
</details>

<details>
<summary>什么是 no route to host？</summary>

- "No route to host" 是在 Linux 中尝试建立到远程主机的网络连接时可能发生的错误消息。
</details>

<details>
<summary>Linux 中硬链接和符号链接有什么区别？（带实际示例）</summary>

**硬链接**

- 对现有文件或目录的直接引用。
- 创建指向相同数据的新名称或条目。
- 原始文件和硬链接都引用相同的基础数据。
- 删除其中一个不会影响另一个。
- 本质上是同一文件的多个名称。

**符号链接（Symlink）**

- 充当指针或快捷方式的特殊文件。
- 包含目标文件或目录的路径或位置。
- 访问时解析指向目标的路径。
- 可以指向不同文件系统上的文件或目录，甚至不存在或已移动的目标。
- 删除原始文件或目录不会自动删除符号链接。
- 如果目标被删除或移动，符号链接变成"损坏"。

**示例**

假设我们在目录 /home/user/ 中有一个名为 "original.txt" 的文件，内容为 "Hello, world!"。

硬链接：
  - 使用 ln 命令创建一个名为 "hardlink.txt" 的硬链接指向 "original.txt"：`ln /home/user/original.txt /home/user/hardlink.txt`
  - 现在 "original.txt" 和 "hardlink.txt" 都引用同一文件并共享相同的数据。
  - 如果您修改 "original.txt" 的内容，更改将在访问 "hardlink.txt" 时可见，反之亦然。
  - 删除 "original.txt" 或 "hardlink.txt" 都不会影响另一个文件。

符号（软）链接：
  - 使用带有 -s 选项的 ln 命令创建一个名为 "symlink.txt" 的符号链接指向 "original.txt"：`ln -s /home/user/original.txt /home/user/symlink.txt`
  - "symlink.txt" 是一个单独的文件，充当指向 "original.txt" 的指针。
  - 如果您修改 "original.txt" 的内容，更改将反映在 "symlink.txt" 中。
  - 删除 "original.txt" 不会自动删除 "symlink.txt"，但如果目标不可用，访问 "symlink.txt" 将导致损坏的链接。

总之，使用硬链接，您有多个名称指向同一文件共享相同的数据，而使用符号链接，您有一个单独的文件充当指向另一个文件或目录的指针。
</details>

**Linux 内部结构和高级（基于场景的问题）：**

<details>
<summary>解释 Linux 启动过程（详细）</summary>

- BIOS/UEFI：当您打开计算机时，调用基本输入/输出系统（BIOS）或统一可扩展固件接口（UEFI）固件。它执行硬件初始化、自测试，并确定启动设备。

- 引导加载程序：GRUB（最常见的 Linux 引导加载程序）将操作系统加载到内存中。

- 内核初始化：一旦引导加载程序移交控制，Linux 内核被加载到内存中。它从其入口点开始执行。内核负责管理系统资源，如内存、进程、设备和文件系统。

- Init 进程：第一个用户空间进程，称为 init 进程，由内核启动。init 进程具有进程 ID（PID）为 1，负责进一步初始化系统。在使用 systemd 作为 init 系统的现代 Linux 发行版中，init 进程被 systemd 进程取代。

- Init 系统/服务：系统服务和守护进程被启动。

- 登录管理器：出现用于用户身份验证的登录屏幕或提示。

- 用户会话：登录后，用户的会话从桌面环境开始。

总之，启动过程涉及固件初始化、引导加载程序加载操作系统、内核接管控制、系统初始化、登录提示和用户会话开始。
</details>

<details>
<summary>系统上的进程无法再记录文件，您将如何调试？</summary>

- **检查文件权限**：验证进程具有写入日志文件或目录的适当权限。确保文件权限和所有权设置正确，以允许进程写入日志。
- **审查日志文件配置**：检查配置文件（例如 /etc/rsyslog.conf 或 /etc/syslog-ng/syslog-ng.conf），确保正确定义了日志文件及其目标。
- **检查磁盘空间**：磁盘空间不足会阻止文件日志记录。使用 df 命令检查可用磁盘空间。确保包含日志文件的文件系统有足够的可用空间来容纳新日志。
- **检查系统日志**：审查系统日志（/var/log/syslog、/var/log/messages 等）中任何相关的错误消息或与日志记录过程相关的问题的迹象。查找与进程相关的日志条目，并检查是否报告了任何错误消息。
- **重新启动日志记录服务**：重新启动与进程关联的日志记录服务（如果您使用 rsyslog 进行日志记录）>> `sudo systemctl restart rsyslog`
</details>

<details>
<summary>如何检查 Linux 系统是否健康？</summary>

- **系统资源使用情况**：
  - 监控 CPU 使用率：使用 `top` 或 `htop` 等工具检查 CPU 使用率并识别消耗过多 CPU 资源的任何进程。
  - 检查内存使用率：使用 `free` 或 `top` 等命令检查内存使用情况，确保有足够的可用内存。
  - 监控磁盘使用率：使用 `df` 或 `du` 命令检查磁盘空间利用率，并识别任何接近容量限制的分区。

- **系统服务和进程**：
  - 检查正在运行的进程：使用 `ps` 或 `top` 查看正在运行的进程，确保关键服务处于活动状态。
  - 验证系统服务：使用服务管理工具，如 `systemctl`（systemd）或 `service`（init）检查基本服务的状态。

- **系统日志**：
  - 审查系统日志：检查 `/var/log/` 中的日志文件（例如 `/var/log/syslog`、`/var/log/messages`）中与系统组件、应用程序或硬件相关的任何错误或警告消息。
  - 实时监控日志文件：使用带有 -f 选项的 `tail` 命令跟踪日志文件，因为新条目被添加。

- **网络连接性**：
  - 检查网络接口：使用 `ifconfig` 或 `ip` 命令验证网络接口的状态和配置。
  - 测试网络连接性：使用 `ping` 或 `traceroute` 测试到远程主机的连接性或检查网络延迟或数据包丢失。

- 硬件监控？
- 安全和更新？
- 备份和恢复？
</details>

<details>
<summary>当您在终端中输入 "ls" 或 "cd" 时会发生什么？（深入探讨幕后发生的事情 - 内核级别）</summary>

- 终端程序接收您键入的命令并识别命令和任何参数。

- 然后 shell 在 `PATH` 环境变量指定的目录中搜索命令二进制文件的位置。它查找具有匹配名称的可执行文件。

- 一旦找到命令二进制文件，shell 启动系统调用，特别是 `execve()` 系统调用，将命令加载到内存中并执行它。

- 内核为命令分配内存，并为输入、输出和错误处理设置文件描述符。

- 内核执行上下文切换，从 shell 转换到命令。

- 命令二进制文件被加载到内存中，其执行开始。

- 当命令执行时，它可能会进行额外的系统调用以与内核交互。例如，"ls" 命令可能会进行系统调用来读取目录内容或检索文件元数据。

- 命令可能会使用控制代码操作终端的显示。

- 命令完成后，内核将控制权返回给 shell。
</details>

<details>
<summary>如何检查服务器是否宕机？</summary>

- ping 命令是一个简单且广泛使用的工具，用于检查 Linux 系统和远程服务器之间的连接性 >> `ping <服务器地址>`
- telnet 命令允许您建立到服务器特定端口的连接。通过尝试连接服务器的端口，您可以确定它是否已启动并接受连接 >> `telnet <服务器地址> <端口>`
- 如果 telnet 命令在您的系统上不可用，您可以使用 nc（netcat），它提供类似的功能 >> `nc -zv <服务器地址> <端口>`
</details>

<details>
<summary>Linux 进程如何在更低级别上被终止？</summary>

- 在 Linux 中，进程可以在更低级别上使用信号终止或杀死。信号是发送到进程以传达各种通知或请求的软件中断。它们可用于优雅地终止进程、强制终止进程或执行其他操作。

  - SIGTERM（信号 15）：当您使用 kill 命令而不指定信号时，这是发送到进程的默认终止信号。它礼貌地请求进程终止，并允许它在退出之前执行清理操作。

  - SIGKILL（信号 9）：此信号强制终止进程。它不允许进程执行任何清理或优雅关闭程序。进程立即被终止。

  - SIGINT（信号 2）：当您在键盘上按 Ctrl+C 时生成此信号。它通常用于中断或终止在前台运行的进程。

  - SIGQUIT（信号 3）：类似于 SIGINT，当您在键盘上按 Ctrl+\ 时生成此信号。它通常请求进程终止并提供用于调试目的的核心转储。
</details>

<details>
<summary>我意外输入了 `cd /bin` 并执行了 `chmod 644 chmod` - 我该如何修复？</summary>

**方法 1 - 从另一个系统复制文件**：
- 如果您有兼容的系统，您可以使用 scp 或 rsync 从另一台服务器获取 chmod 的副本。

```sh
cd /bin
mv chmod chmod.orig
scp twin:/bin/chmod .
diff chmod chmod.orig
```

**方法 2 - 从备份恢复**：

- 如果您有受影响系统的最近备份，可以通过用备份中的版本替换来恢复 `chmod` 命令的正确权限。将 `chmod` 二进制文件从备份位置复制到 `/bin` 目录，确保保留正确的权限。

方法 3
</details>

<details>
<summary>您将如何在 Linux 中排查网络连接问题？</summary>

- **检查网络配置**：验证网络配置是否正确。使用 `ifconfig` 或 `ip` 等命令检查网络接口、IP 地址、子网掩码和网关设置的状态。
- **Ping**：使用 ping 命令测试到远程主机或 IP 地址的基本连接性。例如，`ping 8.8.8.8` ping Google 的公共 DNS 服务器。如果 ping 成功，表示已建立网络连接。
- **检查 DNS 解析**：如果您在通过域名访问网站时遇到问题，检查 DNS 解析是否正常工作。使用 `nslookup` 或 `dig` 命令查询 DNS 服务器，并验证它们是否为给定域返回正确的 IP 地址。
- **检查路由**：使用 `traceroute` 或 `tracepath` 命令跟踪数据包到达目的地的路由。它有助于识别路径上的任何网络跃点或路由问题。
- **防火墙配置**：审查防火墙配置，确保它没有阻止所需的网络流量。检查 `iptables`、`ufw` 或其他防火墙管理工具中的规则。
- **检查网络服务**：确保所需的网络服务，如 DHCP（动态主机配置协议）或 DNS 正在正常运行并正常工作。使用 `systemctl` 或 `service` 等命令检查特定服务的状态。
- **检查网络日志**：检查 `/var/log/` 中的系统日志（例如 `/var/log/syslog`、`/var/log/messages`），查找与网络接口、服务或连接问题相关的任何相关错误消息。
- **使用不同工具测试连接性**：使用网络故障排除工具，如 `netcat`（nc）、`curl` 或 `wget` 测试到远程主机上特定端口或服务的连接性。
</details>

<details>
<summary>如何在 Linux 中排查与远程服务器的连接问题？</summary>

- 检查网络连接性 >> `ping <服务器 IP 或主机名>`
- 验证 DNS 解析 >> `nslookup <服务器主机名>` 或 `dig`
- 检查防火墙设置：验证本地防火墙或任何中间防火墙没有阻止必要的网络流量。暂时禁用防火墙或配置它允许与远程服务器通信所需的特定端口或协议。
- 验证端口连接性 >> `telnet <服务器 IP 或主机名> <端口号>`
- 跟踪路由：使用 traceroute 或 tracepath 命令跟踪到远程服务器的网络路径 >> `traceroute <服务器 IP 或主机名>`
- 审查服务器日志：检查服务器的日志中是否有任何错误消息或连接问题的迹象。检查与服务器上运行的特定服务相关的日志，如 Web 服务器问题的 Apache 日志。
- 检查服务器服务：确保远程服务器上的必要服务正在运行并正确配置。
</details>

<details>
<summary>如何在 Linux 中查看和编辑系统日志？</summary>

- 查看日志 >> `cat /var/log/syslog` - 使用 SUDO
- 编辑日志 >> `vim /var/log/syslog` - 使用 SUDO
</details>

<details>
<summary>使用哪个命令将文件从一台服务器复制到另一台？</summary>

- scp
</details>

<details>
<summary>使用哪个命令将目录从一台服务器复制到另一台？</summary>

- scp -r
</details>


### :small_blue_diamond: 网络

<details>
<summary>什么是 HTTP？</summary>

超文本传输协议（HTTP）是万维网的基础，用于通过超文本链接加载网页。HTTP 是一种应用层协议，旨在在网络设备之间传输信息，并运行在网络协议栈的其他层之上。典型的 HTTP 流程涉及客户端机器向服务器发出请求，然后服务器发送响应消息。

HTTPS 是超文本传输协议的扩展。HTTPS 中的 "S" 代表"安全"。当网站使用 TLS（或 SSL）加密时，它使用安全超文本传输协议（HTTPS）。

基本上，它是带加密的 HTTP。它用于保护计算机网络上的通信安全，并在互联网上广泛使用。HTTPS 对用户页面请求和 Web 服务器返回的页面进行加密和解密。
</details>

<details>
<summary>HTTP 和 HTTPS 有什么区别？</summary>

这两种协议之间最显著的区别是 HTTPS 使用数字证书进行加密和保护，而 HTML 不是。当您使用 HTTPS 访问网站时，您与该网站的连接是加密的。您在该网站上发送或接收的任何信息也是加密的。

协议之间的另一个区别是 HTTPS 使用端口 443，而 HTML 使用端口 80。端口 443 是安全超文本传输协议（HTTPS）的标准端口。端口 80 是非安全超文本传输协议的默认端口。
</details>

<details>
<summary>典型的 HTTP 请求是什么样的？</summary>

HTTP 请求是互联网通信平台（如 Web 浏览器）请求加载网站所需信息的方式。

通过互联网发出的每个 HTTP 请求都携带一系列编码数据，这些数据包含不同类型的信息。典型的 HTTP 请求包含：

1) HTTP 版本类型
2) URL
3) HTTP 方法
4) HTTP 请求头
5) 可选的 HTTP 主体
</details>

<details>
<summary>什么是 HTTP 方法？</summary>

HTTP 方法，有时称为 HTTP 动词，表示 HTTP 请求期望从被查询服务器获得的操作。例如，两个最常见的 HTTP 方法是 'GET' 和 'POST'；'GET' 请求期望返回信息（通常以网站的形式），而 'POST' 请求通常表示客户端正在向 Web 服务器提交信息（如表单信息，例如提交的用户名和密码）。
</details>

<details>
<summary>什么是 HTTP 请求头？</summary>

HTTP 头包含存储在键值对中的文本信息，它们包含在每个 HTTP 请求中。这些头部传达核心信息，例如客户端使用的浏览器和正在请求的数据。
</details>

<details>
<summary>HTTP 请求主体中有什么？</summary>

请求的主体是包含请求正在传输的信息的"主体"部分。HTTP 请求的主体包含任何提交给 Web 服务器的信息，如用户名和密码，或输入到表单中的任何其他数据。
</details>

<details>
<summary>HTTP 响应中有什么？</summary>

HTTP 响应是 Web 客户端（通常是浏览器）从互联网服务器作为对 HTTP 请求的回答而收到的内容。这些响应基于 HTTP 请求中要求的内容传达有价值的信息。

典型的 HTTP 响应包含：

1) HTTP 状态码
2) HTTP 响应头
3) 可选的 HTTP 主体
</details>

<details>
<summary>什么是 HTTP 状态码？</summary>

HTTP 状态码是 3 位数的代码，最常用于指示 HTTP 请求是否已成功完成。状态码分为以下 5 个块：

- 1xx 信息性
- 2xx 成功
- 3xx 重定向
- 4xx 客户端错误
- 5xx 服务器错误

"xx" 指的是 00 到 99 之间的不同数字。

以数字 '2' 开头的状态码表示成功。例如，在客户端请求网页后，最常见的响应状态码是 '200 OK'，表示请求已正确完成。

如果响应以 '4' 或 '5' 开头，则表示有错误，网页将不会显示。以 '4' 开头的状态码表示客户端错误（在 URL 中输入错误时经常会遇到 '404 NOT FOUND' 状态码）。以 '5' 开头的状态码表示服务器端出现了问题。状态码也可以以 '1' 或 '3' 开头，分别表示信息性响应和重定向。
</details>

<details>
<summary>什么是 HTTP 响应头？</summary>

与 HTTP 请求一样，HTTP 响应带有头部，传达重要信息，如响应主体中发送的数据的语言和格式。
</details>

<details>
<summary>HTTP 响应主体中有什么？</summary>

对 'GET' 请求的成功 HTTP 响应通常有一个主体，包含所请求的信息。在大多数 Web 请求中，这是 Web 浏览器将转换为网页的 HTML 数据。
</details>

<details>
<summary>TCP vs UDP</summary>

协议是管理数据如何在网络上格式化和发送的规则。TCP 和 UDP 是执行相同工作的两种不同方法：通过互联网传输数据。它们使服务器和设备能够通信，以便您可以发送电子邮件、观看 Youtube、玩游戏和浏览网页。

TCP（传输控制协议）和 UDP（用户数据报协议）之间的主要区别是 TCP 是基于连接的协议，而 UDP 是无连接的。虽然 TCP 更可靠，但它传输数据的速度更慢。UDP 可靠性较低但工作更快。这使得每种协议都适合不同类型的数据传输。
</details>

<details>
<summary>什么是 DNS？</summary>

DNS 解析过程涉及将主机名（如 www.google.com）转换为计算机友好的 IP 地址（如 192.168.1.1）。互联网上的每个设备都被分配一个 IP 地址，该地址对于找到适当的互联网设备是必要的——就像使用街道地址找到特定的房屋一样。当用户想要加载网页时，必须在用户输入到 Web 浏览器中的内容（example.com）和定位 example.com 网页所需的机器友好地址之间进行转换。
</details>

<details>
<summary>DNS 是如何工作的？</summary>

DNS（域名系统）通过将人类友好的域名（如 www.example.com）转换为计算机在互联网上相互识别所使用的 IP 地址（如 192.168.1.1）来工作。以下是简化的分步过程：

1. 用户在 Web 浏览器中输入域名。
2. 计算机首先检查其本地 DNS 缓存，看是否已经知道相应的 IP 地址。
3. 如果未找到，计算机向 DNS 解析器（通常由您的互联网服务提供商或公共 DNS 服务（如 Google 的 8.8.8.8）提供）发送 DNS 查询。
4. DNS 解析器在其缓存中搜索 IP 地址。如果未找到，它开始递归过程：
  a. 解析器查询根 DNS 服务器以找到顶级域（如 .com）的权威 DNS 服务器。
  b. 解析器然后查询顶级域的权威 DNS 服务器以找到特定域（如 example.com）的权威服务器。
  c. 最后，解析器查询域的权威服务器以获取请求域（www.example.com）的 IP 地址。
5. 权威 DNS 服务器以 IP 地址响应，解析器缓存此信息以供将来使用。
6. 解析器将 IP 地址返回给用户的计算机。
7. 计算机现在可以与提供的 IP 地址的 Web 服务器建立连接，允许用户访问与域名关联的网站。

本质上，DNS 充当互联网的电话簿，将用户友好的域名转换为计算机通信所需的数字地址。
</details>

<details>
<summary>什么是 TLS？</summary>

TLS（传输层安全）是一种加密协议，通过计算机网络（如互联网）提供安全通信。它通过加密两个系统（通常是 Web 浏览器和 Web 服务器）之间传输的数据来确保数据隐私和完整性。TLS 通常用于保护在线交易（如信用卡付款和敏感数据传输），通过在客户端和服务器之间建立安全的加密连接。这种加密有助于防止传输过程中的窃听和数据篡改。
</details>

<details>
<summary>什么是 CIDR 范围？</summary>

CIDR（无类域间路由）范围是一种以比传统使用类（A 类、B 类、C 类等）的子网划分更灵活的方式表示和分配 IP 地址和子网的方法。在 CIDR 表示法中，IP 地址后跟一个斜杠（"/"）和一个数字，表示地址中网络部分的位数。这是一个简单的例子：

IP 地址：192.168.1.0
CIDR 表示法：192.168.1.0/24

在此示例中，"/24" 表示 IP 地址的前 24 位用于标识网络，留下 8 位用于主机地址。与较旧的基于类的系统（例如 A 类、B 类、C 类）相比，这允许对 IP 地址分配和子网划分进行更精细的控制。

CIDR 表示法广泛用于网络中以指定 IP 地址范围，使其更容易管理和高效分配 IP 地址。
</details>

<details>
<summary>什么是入站和出站流量？</summary>

在网络安全中，"入站"和"出站"指的是数据或流量进出网络、系统或设备的移动：

**入站流量：**这是进入网络或系统的传入流量。入站流量通常来自外部来源，如互联网，并通过网关、路由器或防火墙流入网络。监控和控制入站流量对于安全目的很重要，以防止未经授权的访问或攻击。

**出站流量：**另一方面，出站流量是离开网络或系统并前往外部目的地的传出流量。出站流量可能包括离开公司网络访问网站、发送电子邮件或与云服务通信的数据。管理出站流量对于监控离开网络的数据和执行与数据传输相关的策略至关重要。

总之，入站流量进入网络，而出站流量离开网络。网络管理员经常使用防火墙规则和安全措施来控制和保护入站和出站流量，以保护网络免受威胁并确保正确的数据流。
</details>

<details>
<summary>交换机 vs 集线器有什么区别？</summary>

交换机和集线器都是用于在局域网（LAN）中连接多个设备的网络设备，但它们以根本不同的方式运行：

**交换机：**

交换机在 OSI 模型的数据链路层（第 2 层）运行。
它是一种智能设备，检查数据包的 MAC（媒体访问控制）地址以确定将它们转发到何处。
交换机在发送方和接收方之间创建专用的点对点连接，通过减少冲突来提高网络效率。
它们可以过滤和仅将流量转发到需要它的特定设备，增强网络安全性和性能。
由于其效率和处理高流量负载的能力，交换机在现代网络中很常见。

**集线器：**

集线器在 OSI 模型的物理层（第 1 层）运行。
它是一种基本的被动设备，简单地将传入的数据包广播到所有连接的设备，没有任何智能。
集线器不检查 MAC 地址或做出关于将数据发送到何处的决定；它们不加选择地将数据发送到所有连接的设备。
这种广播方法可能导致网络拥塞和冲突，尤其是在较大的网络中。
集线器被认为对于现代网络来说已经过时且效率低下，如今很少使用。

总之，交换机是更先进和高效的网络设备，智能地将数据包转发到适当的接收者，而集线器是基本的、过时的设备，将数据广播到所有连接的设备，导致网络通信效率较低。交换机是构建现代、高性能 LAN 的首选。
</details>

<details>
<summary>交换机 vs 路由器有什么区别？</summary>

**交换机：**

交换机在 OSI 模型的数据链路层（第 2 层）运行。
它用于连接局域网（LAN）内的设备。
交换机基于 MAC（媒体访问控制）地址做出转发决策，并在同一 LAN 内的设备之间创建高效的专用连接。
它们主要用于本地流量管理，在路由不同网络之间的流量方面没有作用。

**路由器：**

路由器在 OSI 模型的网络层（第 3 层）运行。
它将不同的网络连接在一起并指导它们之间的流量。
路由器使用 IP 地址做出路由决策，确定数据包到达其目的地的最合适路径，无论目的地是在同一本地网络内还是在不同的网络中（例如互联网）。
路由器对于互连多个 LAN 和促进不同网络上设备之间的通信至关重要。

总之，交换机用于单个 LAN 内的本地网络流量管理，而路由器用于连接和路由不同网络之间的流量，包括路由 LAN 和更广泛的互联网之间的流量。两种设备在网络通信和连接性方面都起着关键作用。
</details>

<details>
<summary>HTTPS vs WebSockets 有什么区别？</summary>

HTTPS 和 WebSockets 都是用于 Web 通信的协议，但它们服务于不同的目的并以不同的方式运行：

**HTTPS（安全超文本传输协议）：**

- HTTPS 是用于通过互联网进行安全通信的 HTTP 协议的扩展。
它加密 Web 浏览器和 Web 服务器之间传输的数据，提供数据机密性和完整性。
- HTTPS 使用 SSL/TLS（安全套接字层/传输层安全）在客户端和服务器之间建立安全的加密连接。
- 它常用于安全 Web 浏览、在线交易和保护敏感数据，如登录凭证和个人信息。
- HTTPS 是请求-响应协议，意味着客户端向服务器发送请求，服务器以请求的数据响应。

**WebSockets：**
- WebSockets 是一种通过单个 TCP 连接提供全双工通信通道的协议。
与基于请求-响应且无状态的 HTTP(S) 不同，WebSockets 允许客户端（例如 Web 浏览器）和服务器之间的双向实时通信。
- WebSockets 通常用于需要实时更新的应用程序，如聊天应用程序、在线游戏、协作工具和实时数据馈送。
- 它们对于需要持续通信的场景更高效，因为它们消除了重复建立新连接的需要。
- WebSockets 允许数据从服务器推送到客户端，反之亦然，而没有频繁 HTTP 请求的开销。

总之，HTTPS 是用于保护 Web 通信安全的协议，而 WebSockets 提供通过单个长寿命连接进行实时双向通信的框架。它们用于不同的目的，但在需要安全和实时通信的 Web 应用程序中可以相互补充。
</details>

<details>
<summary>解释三次握手是如何工作的？</summary>

三次握手是在 TCP/IP 网络中用于在主机和客户端之间创建连接的方法。它被称为三次握手，因为它是一个三步方法，客户端和服务器在其中交换数据包。三个步骤如下：客户端向服务器发送 SYN（同步）数据包，检查服务器是否启动或有开放端口。如果有开放端口，服务器向客户端发送 SYN-ACK 数据包。客户端确认这一点并向服务器发回 ACK（确认）数据包。
</details>

<details>
<summary>无状态 vs 有状态防火墙？</summary>

无状态和有状态防火墙是两种类型的网络安全设备，它们过滤和控制传入和传出的网络流量，但它们以不同的方式进行：

**无状态防火墙：**

- 无状态防火墙仅基于源和目标 IP 地址以及端口号过滤流量。
它们不维护有关正在进行网络连接状态的任何信息。
- 无状态防火墙更简单、更快，但缺乏基于连接上下文或状态做出决策的能力。
- 每个数据包都是独立评估的，不考虑它是否是已建立连接的一部分或是否是对出站请求的合法响应。
- 无状态防火墙常用于基本的网络安全设置，适用于基本安全级别足够的场景。

**有状态防火墙：**

- 有状态防火墙，也称为动态数据包过滤防火墙，维护活动网络连接状态的表。
- 它们跟踪 TCP 和 UDP 会话的状态，包括每个连接的状态（例如已建立、相关、新建）及其相关端口。
- 有状态防火墙基于网络流量的上下文做出决策，允许它们根据数据包是否是合法、已建立连接的一部分来允许或拒绝数据包。
- 这种上下文感知使有状态防火墙在防范各种类型的攻击（如端口扫描和某些形式的数据包级攻击）方面更有效。
- 它们常用于企业网络，与无状态防火墙相比提供更高级别的安全性。

总之，无状态防火墙仅基于基本信息（如 IP 地址和端口号）过滤流量，而有状态防火墙维护有关活动连接状态的信息并基于流量的上下文做出决策。有状态防火墙通常更先进，为现代网络环境提供更好的安全性。
</details>

<details>
<summary>什么是 VPC？</summary>

VPC 代表虚拟私有云。它是云计算基础设施的基本组成部分，特别是在 Amazon Web Services（AWS）和 Microsoft Azure 等服务中。

**VPC（虚拟私有云）：**

- VPC 是云提供商网络的逻辑隔离部分，您可以在其中启动和管理您的虚拟资源，如虚拟机（VM）、数据库和存储。
- 它允许您在云中创建自己的私有网络，包括私有 IP 地址、子网、路由表和安全组。
- VPC 提供对网络配置、安全性和资源间通信的控制，使构建安全和可扩展的基于云的应用程序成为可能。
- 您还可以将 VPC 连接到您的本地数据中心或其他 VPC，创建混合或多云网络。
- VPC 对于确保云环境中的网络隔离、安全性和资源组织至关重要。
</details>

<details>
<summary>什么是子网划分？</summary>

子网划分是将较大的 IP 网络划分为更小、更易管理的子网络或"子网"的过程。这种做法通常用于网络中：

- 提高网络效率：子网划分允许您在更大的网络内创建较小的段。这可以通过将流量隔离到特定子网来帮助减少广播流量并提高整体网络性能。

- 增强安全性：通过将网络划分为子网，您可以更有效地实施访问控制列表（ACL）和防火墙规则。这有助于控制和保护网络不同部分之间的流量。

- IP 地址管理：子网划分有助于高效的 IP 地址分配。每个子网可以有自己的 IP 地址范围，使组织内管理和分配 IP 地址更容易。

- 隔离和分段：子网可以将不同类型的设备或服务相互隔离。例如，您可以将服务器放在一个子网中，将用户设备放在另一个子网中，以提高安全性和管理性。

子网划分涉及将 IP 地址范围划分为更小的连续块，每个块都有自己的网络地址和主机地址范围。这通常通过修改与 IP 地址范围关联的子网掩码来完成。子网掩码指定 IP 地址的哪一部分是网络部分，哪一部分是主机部分。

例如，如果您有 IP 地址范围 192.168.0.0/24（其中"/24"表示子网掩码为 255.255.255.0），您可以将其划分为更小的子网，如 192.168.0.0/25 和 192.168.0.128/25，每个子网拥有原始 IP 地址范围的可用主机地址的一半。
</details>

<details>
<summary>什么是 DHCP？</summary>

DHCP 代表动态主机配置协议。它是一种网络协议，用于自动化和简化为本地网络上的设备分配 IP 地址和其他网络配置设置的过程。

**DHCP（动态主机配置协议）：**

- DHCP 是一种客户端-服务器协议，常用于局域网（LAN）和互联网上。
- 它消除了在网络中每个设备上手动配置 IP 地址的需要。
- 当设备（客户端）连接到网络时，它向 DHCP 服务器（通常是路由器或专用 DHCP 服务器）发送 DHCP 请求。
- DHCP 服务器以可用的 IP 地址、子网掩码、默认网关、DNS 服务器地址和其他配置参数响应。
- 客户端然后使用提供的信息配置自身，使其准备好在网络上通信。
</details>

#### 高级 + 基于场景的问题：

<details>
<summary>当我在浏览器中输入 google.com 时，实际发生了什么？（基础版本）</summary>

当您在 Web 浏览器的地址栏中输入"google.com"并按 Enter 键时，幕后会发生几个步骤来显示 Google 主页。以下是发生情况的简单分解：

**DNS 解析：**

- 您的 Web 浏览器首先检查其本地缓存，看是否已经知道与"google.com"关联的 IP 地址。如果知道，它跳过接下来的步骤。
- 如果在缓存中未找到，您的浏览器向 DNS 解析器发送 DNS（域名系统）解析请求。这通常由您的互联网服务提供商（ISP）或公共 DNS 服务（如 Google 的 8.8.8.8）提供。
- DNS 解析器检查其缓存，看是否有"google.com"的 IP 地址。如果没有，它启动 DNS 解析过程。

**DNS 解析过程：**

- DNS 解析器查询根 DNS 服务器以找到顶级域（TLD）的权威 DNS 服务器，在这种情况下是"com"。
- 根 DNS 服务器以"com"TLD 的权威 DNS 服务器的 IP 地址响应。
- 解析器然后查询"com"TLD 的权威 DNS 服务器以找到"google.com"的权威 DNS 服务器。
- "google.com"的权威 DNS 服务器以与"google.com"关联的 IP 地址响应。

**IP 地址检索：**

- DNS 解析器将"google.com"的 IP 地址返回给您的 Web 浏览器。

**HTTP 请求：**

- 您的浏览器向收到的"google.com"的 IP 地址发起 HTTP（超文本传输协议）请求。
- 该请求包括额外信息，如您尝试访问的特定网页（例如，"/"，通常代表主页）。

**服务器处理：**

- 位于提供的 IP 地址的 Google Web 服务器接收 HTTP 请求。
- 服务器处理请求并生成适当的响应。

**响应传输：**

- Web 服务器发回 HTTP 响应，其中包括呈现 Google 主页所需的 HTML、CSS、JavaScript 和其他资源。

**渲染网页：**

您的浏览器接收 HTTP 响应并开始在屏幕上呈现 Google 主页。
它可能还会对 HTML 中引用的图像、样式表和脚本发出额外请求，以完全加载和显示页面。

**页面显示：**

一旦所有资源都加载完毕，您的 Web 浏览器在屏幕上显示 Google 主页，您可以与之交互。

总之，当您在浏览器中输入"google.com"时，会发生一系列涉及 DNS 解析、HTTP 请求和服务器响应的复杂步骤，以检索和显示您请求的网页。此过程确保您可以使用人类可读的域名访问网站，而互联网在幕后使用 IP 地址来路由和传送内容。
</details>

<details>
<summary>我无法访问网站，如何进行故障排除？（使用深入的 Linux + 网络知识）</summary>

**检查网络连接性：**

- 确保您的 Linux 机器有工作的互联网连接。尝试 ping 可靠的网站或 IP 地址（例如，`ping google.com` 或 `ping 8.8.8.8` 对应 Google 的 DNS）。

**DNS 解析：**

- 验证 DNS 解析是否正常工作。尝试使用 `nslookup` 或 `dig` 解析网站的 IP 地址（例如，`nslookup website.com` 或 `dig website.com`）。
- 在 /etc/resolv.conf 中检查您的 DNS 服务器配置。确保它指向有效的 DNS 服务器（例如，`nameserver 8.8.8.8` 对应 Google 的 DNS）。

**检查 Hosts 文件：**

- 确保网站没有被 `/etc/hosts` 文件中的条目阻止。检查可能重定向网站的任何条目。

**防火墙规则：**

- 检查防火墙是否阻止传出或传入流量。使用 `iptables` 或 firewall-cmd 命令检查防火墙规则。

**Web 代理：**

- 如果您在代理服务器后面，确保在您的环境中正确配置了代理设置，包括 `HTTP_PROXY` 和 `HTTPS_PROXY` 环境变量。

**浏览器问题：**

- 尝试从不同的 Web 浏览器或隐私/无痕浏览窗口访问网站，以排除与浏览器相关的问题。

**SSL/TLS 问题：**

- 如果您收到与 SSL/TLS 相关的错误，确保您的系统安装了最新的 CA 证书。您还可以使用 openssl 命令检查 SSL/TLS 问题（例如，`openssl s_client -connect website.com:443`）。

**检查 DNS 缓存：**

- 如果您对 DNS 配置进行了更改，使用 `systemctl restart systemd-resolved`（在使用 systemd-resolved 的系统上）或 `sudo /etc/init.d/nscd restart`（在使用 nscd 的系统上）清除 DNS 缓存。

**跟踪路由（Traceroute）：**

- 使用 traceroute 或 tracepath 命令跟踪到网站的网络路径（例如，`traceroute website.com` 或 `tracepath website.com`）。

**检查系统日志：**

- 检查 `/var/log` 中的系统日志（例如，`/var/log/syslog`、`/var/log/messages`、`/var/log/auth.log`）中是否有任何与网络相关的错误或问题。

**检查 DNS 服务器状态：**

- 通过 ping DNS 服务器或使用 `dig` 等工具验证 DNS 服务器的可用性和响应性。

**检查网站状态：**

网站本身可能宕机了。在"DownDetector"或"Is It Down Right Now?"等服务上检查其状态。

**数据包捕获（可选）：**

- 作为最后的手段，您可以使用 `tcpdump` 或 `wireshark` 等数据包捕获工具捕获网络流量并分析问题。
</details>

<details>
<summary>您能分解 OSI 模型并说明它代表什么吗？</summary>

OSI（开放系统互连）模型是一个概念框架，用于标准化和定义电信或网络系统的功能。它由七个不同的层组成，每一层负责通信过程中的特定任务。以下是 OSI 模型的分解以及每一层的含义：

**物理层（第 1 层）：**

含义：此层处理物理介质和在物理网络上传输原始二进制数据。
职责：它定义网络的物理特性，如电缆、连接器、电压和传输速度。它还规定了比特如何在网络介质上表示、编码和传输。

**数据链路层（第 2 层）：**

含义：此层专注于本地网络上直接连接设备之间的可靠数据传输。
职责：它管理将数据帧化的帧、错误检测和纠正以及流控制。以太网和 Wi-Fi 在此层运行。MAC（媒体访问控制）地址用于设备识别。

**网络层（第 3 层）：**

含义：网络层负责在不同网络之间路由数据包以到达其目的地。
职责：它处理逻辑地址、路由和数据包转发。互联网协议（IP）在此层运行，IP 地址用于标识不同网络上的设备。

**传输层（第 4 层）：**

含义：此层确保不同网络上设备之间的端到端通信和数据可靠性。
职责：它管理数据分段、流控制、错误检测和重传。TCP（传输控制协议）和 UDP（用户数据报协议）是常用的传输层协议。

**会话层（第 5 层）：**

含义：会话层在两个设备之间建立、管理和终止通信会话。
职责：它处理会话设置、维护和拆解，包括同步、检查点和中断情况下的数据恢复。

**表示层（第 6 层）：**

含义：此层确保数据以应用程序层可读的格式呈现。
职责：它处理数据转换、加密、压缩和字符编码，确保一个设备发送的数据能被另一个设备理解。

**应用层（第 7 层）：**

含义：应用层是顶层，代表用户与之交互的实际软件应用程序。
职责：它为应用软件提供与底层通信的平台无关接口。此层包括 HTTP、FTP、SMTP 和 DNS 等协议，这些协议支持特定的应用级功能。
</details>

<details>
<summary>mTLS 是如何工作的，它与 TLS 有何比较？</summary>

mTLS（相互 TLS）是 TLS 的扩展，要求客户端和服务器都向对方验证其身份。在传统的 TLS 中，只有服务器需要向客户端证明其身份。而在 mTLS 中，双方都需要出示证书，确保双向身份验证。

主要区别：
- TLS：仅服务器验证（单向身份验证）
- mTLS：客户端和服务器都验证（双向身份验证）

mTLS 适用于需要高安全性的场景，如 API 访问、微服务通信等。
</details>

### :small_blue_diamond: Git

<details>
<summary>什么是 Git？</summary>

Git 是当今世界上使用最广泛的现代版本控制系统。它用于将多个用户的代码贡献收集到一个地方（仓库）。提供完整的历史记录、工作流程，并允许代码回滚和修补。
</details>

<details>
<summary>Git 和 SVN 有什么区别？</summary>

SVN 和 Git 都是强大的版本控制系统，但它们使用不同的方法来管理和合并代码更改。Git 使用分布式模型，而 SVN 使用集中式模型。

SVN 的集中式仓库模型使管理贡献者和贡献更容易。Git 不支持代码库访问限制——有权访问仓库的贡献者可以访问整个仓库。相比之下，SVN 提供细粒度控制，允许对特定贡献者限制到目录和文件级别。

能够本地工作和离线工作是 Git 的一个主要优势。SVN 要求贡献者连接到主仓库服务器，这基本上消除了离线工作的可能性。

在合并和冲突解决方面，Git 也优于 SVN。Git 是为开源环境设计的，其中许多贡献者可能正在处理代码库的相同部分。为了允许这种类型的协作，Git 建立了强大的解决合并冲突的系统，使过程更顺畅、更易于管理。
</details>

<details>
<summary>基本的 Git 工作流程是什么？</summary>

工作目录 >   暂存区 >  本地仓库 >   远程仓库
            git add           git commit    git push
</details>

<details>
  <summary>git pull 和 git fetch 有什么区别</summary>

git fetch 和 pull 之间的关键区别在于 git pull 直接将远程仓库的更改复制到您的工作目录中，而 git fetch 不会。git fetch 命令仅将更改复制到您的本地 Git 仓库中。git pull 命令则两者都做。

git pull 的好处：本地 Git 仓库现在与远程仓库同步。本地文件系统拥有最新的、最新的文件。

git fetch 的好处：如果您正在积极处理 Git 跟踪的文件，但仍想用远程仓库的最新更改更新本地仓库，请使用 git fetch 命令。
</details>

<details>
<summary>什么是 git cherry-pick？</summary>

git cherry-pick 是一个 Git 命令，用于将特定的提交（或一系列提交）从一个分支应用到另一个分支。它允许您从一个分支的历史记录中选择并"挑拣"单个提交，并将它们应用到另一个分支上。当您想将特定更改或修复从一个分支带到另一个分支而不合并整个分支时，这很有用。

git cherry-pick 的基本语法如下：

```bash
git cherry-pick <提交哈希>
```

<提交哈希> 是您要应用的提交的唯一标识符（SHA-1 哈希）。
</details>

<details>
<summary>Git 中的 HEAD 是什么？</summary>

在 Git 中，HEAD 是指向当前检出分支中最新提交的指针。它表示分支的当前状态，用于导航提交历史记录和跟踪更改。当处于"分离"状态时，HEAD 直接指向特定的提交。
</details>

<details>
<summary>我什么时候使用 Git stash？</summary>

当您需要临时保存工作目录中的更改而不提交它们时，您在 Git 中使用 git stash。这通常在您想要切换到不同的分支、从远程仓库拉取更改或执行其他需要干净工作目录的操作时完成。

以下是您应该使用 git stash 的常见情况：

**切换分支**：当您在一个分支上工作并需要切换到另一个分支，但您的工作目录中有未提交的更改时。使用 git stash 允许您保存这些更改、切换分支，然后将更改应用到新分支。

```bash
git stash        # 保存更改
git checkout another-branch   # 切换分支
git stash apply  # 将保存的更改应用到新分支
```

**拉取或获取更改**：在从远程仓库拉取或获取更改之前，您可以隐藏本地更改以确保工作目录干净。这有助于防止 Git 尝试将传入更改与您的本地修改合并时可能出现的冲突。

```bash
git stash        # 保存更改
git pull origin main   # 从远程拉取更改
git stash apply  # 将保存的更改应用到您的工作目录
```

**临时更改**：如果您正在处理某个功能但需要快速修复或测试不相关的内容，您可以在进行临时更改之前隐藏当前更改。之后，您可以重新应用隐藏的更改。

```bash
git stash        # 保存功能更改
# 进行并测试快速修复或不相关的更改
git stash apply  # 重新应用保存的功能更改
```

**解决冲突**：在解决合并或变基冲突时，git stash 可以提供帮助。您可以隐藏更改，然后执行合并或变基。解决冲突后，您可以再次应用隐藏的更改。

```bash
git stash        # 保存更改
# 在合并或变基期间解决冲突
git stash apply  # 冲突解决后应用保存的更改
```
</details>

<details>
<summary>git reset 有什么作用？</summary>

`git reset` 是一个 Git 命令，用于将 HEAD 和可选的索引（暂存区）移动到指定的提交。它有不同的模式，包括 soft（仅移动 HEAD）、mixed（默认，移动 HEAD 并取消暂存更改）和 hard（移动 HEAD、取消暂存更改并丢弃工作目录中的更改）。您可以使用它来取消暂存更改、移动分支指针、撤回提交和修改最后一次提交。请谨慎使用，因为它会影响提交历史。

以下是 `git reset` 的主要功能：

- 取消暂存更改
- 移动 HEAD
- 撤回提交：git reset
- 用于修改的混合模式
</details>

<details>
<summary>什么是 Git fork？git fork、clone 和 branch 有什么区别？</summary>

- **Git Fork**：在 Git 托管平台上创建仓库的副本，通常用于协作贡献。
- **Git Clone**：从远程创建 Git 仓库的本地副本，启用本地开发。
- **Git Branch**：在仓库内创建单独的开发线，通常用于功能或错误修复。
</details>

<details>
  <summary>`git stash pop` 和 `git stash apply` 有什么区别？</summary>

- `git stash pop` 应用并删除最近的隐藏。
- `git stash apply` 应用最近的隐藏但将其保留在隐藏列表中以供将来使用或参考。
</details>

#### 高级：

<details>
<summary>我需要更新我的本地仓库，使用什么命令？</summary>

- 使用 `git fetch` 来检索远程更改。
- 使用 `git pull origin <branch-name>` 来获取并合并更改到当前分支。
- 使用 `git rebase origin/<branch-name>` 来在当前分支之上重新定位您的更改。
</details>

<details>
<summary>如何解决 Git 中的合并冲突？</summary>

解决合并冲突的步骤：

1. 识别冲突文件：Git 会标记有冲突的文件。
2. 打开冲突文件并查看冲突标记（<<<<<<<、=======、>>>>>>>）。
3. 编辑文件以解决冲突，保留所需的更改并删除冲突标记。
4. 使用 `git add <文件>` 标记冲突已解决。
5. 对所有冲突文件重复此过程。
6. 使用 `git commit` 完成合并。

常用命令：
```bash
git status                    # 查看冲突文件
git diff                      # 查看冲突详情
git checkout --theirs <文件>   # 接受他们的版本
git checkout --ours <文件>    # 接受我们的版本
git merge --abort             # 取消合并
```
</details>

<details>
<summary>什么是 git rebase？它与 merge 有什么区别？</summary>

**Git Rebase**：
- rebase 将一系列提交移动到新的基础提交上
- 它会重写提交历史，创建线性的历史记录
- 语法：`git rebase <基础分支>`

**与 Merge 的区别**：

**Merge**：
- 保留完整的历史记录，包括合并提交
- 创建非线性的历史记录
- 更安全，不会重写历史
- 语法：`git merge <分支>`

**选择标准**：
- 使用 rebase 保持清洁的线性历史（适用于功能分支）
- 使用 merge 保留完整的开发历史（适用于长期分支）
- 不要对已推送的公共分支使用 rebase
</details>

<details>
<summary>解释 .gitignore 文件的作用</summary>

.gitignore 文件指定 Git 应该忽略的文件和模式。这些文件不会被 Git 跟踪。

常见用途：
- 忽略构建输出（如 /target、/build）
- 忽略依赖目录（如 /node_modules、/vendor）
- 忽略环境配置文件（如 .env）
- 忽略 IDE 文件（如 .vscode、.idea）
- 忽略日志文件和临时文件

示例：
```
# 编译输出
*.class
*.exe

# 依赖目录
node_modules/
vendor/

# 环境变量
.env
.env.local

# IDE
.vscode/
.idea/

# 日志
*.log
```
</details>

### :small_blue_diamond: AWS 🌩️

#### 基础

<details>
<summary>什么是 AWS？</summary>

AWS（Amazon Web Services）是亚马逊提供的云计算平台，提供超过 200 种功能齐全的服务，包括计算、存储、数据库、网络、分析、机器学习、人工智能、物联网、移动等。AWS 让企业能够在云中构建复杂的应用程序，提供灵活、可扩展和经济高效的解决方案。
</details>

<details>
<summary>AWS 中哪两种服务可以用来存储机密信息？</summary>

两种安全存储机密信息的 AWS 服务：

- **AWS Secrets Manager**：专门设计用于管理和轮换敏感信息（如数据库密码、API 密钥和其他凭证）的服务。它为机密提供加密、自动轮换和访问控制。

- **AWS Parameter Store**：允许您以分层结构存储和管理配置数据（包括机密）的服务。通常用于以安全方式存储应用程序配置参数和机密。
</details>

<details>
<summary>AWS 中的可用区和区域有什么关系？</summary>

- **区域**是由多个隔离的可用区组成的地理区域。AWS 区域彼此完全分离，分布在世界各地，以提供地理多样性和冗余性。

- **可用区（AZ）**是 AWS 区域内的数据中心或设施。每个可用区在物理上与其他可用区分离，并设计为与同一区域内其他可用区的故障隔离。这种隔离确保了高可用性和容错性。

总之，AWS 区域由多个可用区组成。当您为资源选择区域时，您是在选择具有多个隔离数据中心（可用区）的特定地理位置来托管您的服务和数据。这种设置为您的应用程序和基础设施提供了冗余性、可扩展性和弹性。
</details>

<details>
<summary>什么是自动扩展？</summary>

自动扩展是一种云计算功能，可根据实时需求自动分配给您的应用程序的资源数量（如服务器）。它有助于确保您的应用程序能够通过根据需要添加或删除资源来高效处理不同级别的流量，从而提高性能和成本效率。
</details>

<details>
<summary>哪些服务可以帮助最小化 DDoS 攻击？</summary>

为了最小化基础设施上的分布式拒绝服务（DDoS）攻击，您可以使用以下服务：

- **AWS Shield**：AWS Shield 是托管的 DDoS 保护服务，保护您的应用程序免受大规模、复杂的攻击。
</details>

<details>
<summary>什么是 AMI？</summary>

- **AMI（Amazon Machine Image）**是预配置和模板化的虚拟机映像，用于在 Amazon Web Services（AWS）中创建虚拟服务器（EC2 实例）。它包含操作系统、软件应用程序和基于云的服务器所需的任何自定义配置。AMI 使您能够快速启动和复制服务器实例，更容易扩展基础设施并部署一致的计算环境。
</details>

<details>
<summary>有哪些不同类型的负载均衡器？</summary>

主要有三种类型的负载均衡器：

- **应用程序负载均衡器（ALB）**：ALB 在应用层（第 7 层）运行，非常适合路由 HTTP 和 HTTPS 流量。它们能够进行基于内容的路由、SSL 终止，并支持基于容器的应用程序。

- **网络负载均衡器（NLB）**：NLB 在传输层（第 4 层）运行，专为处理 TCP、UDP 和 TLS 流量而设计。它们高性能，适用于低延迟和高吞吐量的工作负载。

- **经典负载均衡器（CLB）**：CLB 是 AWS 中的传统负载均衡器，提供基本的第 4 层和第 7 层负载均衡功能。通常用于简单的流量分配需求。

每种类型的负载均衡器都有特定的用例和功能，允许您选择最适合您应用程序需求的一种。
</details>

#### 网络

<details>
<summary>什么是 VPC？</summary>

VPC（虚拟私有云）是 Amazon Web Services（AWS）提供的虚拟网络环境。它允许您创建和配置 AWS 云的逻辑隔离部分，您可以在其中启动 AWS 资源，如虚拟服务器（EC2 实例）、数据库等。

VPC 的主要功能包括：

- **隔离**：VPC 提供网络隔离，允许您创建私有和公共子网来控制对资源的访问。

- **自定义 IP 地址范围**：您可以定义 VPC 的 IP 地址范围，使您能够设计网络架构。

- **安全组和网络 ACL**：这些允许您控制进出 VPC 内资源的传入和传出流量。

- **连接选项**：VPC 可以使用各种网络选项连接到其他 VPC、本地网络和互联网。

- **子网**：VPC 被划分为子网，每个子网与特定的可用区关联。子网用于分配资源并提供高可用性。

总之，VPC 是 AWS 中的基本网络组件，让您创建虚拟网络环境来托管和管理基于云的资源，并控制网络架构和安全性。
</details>

<details>
<summary>子网是如何工作的？</summary>

- 子网就像云网络中的独立社区。每个子网都有自己的 IP 地址区域，并与其他子网隔离。它们通常放置在云的不同部分以增加安全性，您可以控制流量进出每个子网。这有助于保持云资源的组织和安全。
</details>

<details>
<summary>什么是安全组和网络 ACL？</summary>

**安全组（Security Groups）**：
- 作用于实例级别（有状态）
- 包含允许规则（默认拒绝所有）
- 支持允许特定 IP、端口和协议
- 自动跟踪连接状态

**网络 ACL（Network Access Control Lists）**：
- 作用于子网级别（无状态）
- 包含允许和拒绝规则
- 规则按编号顺序评估
- 需要为入站和出站流量分别配置规则
</details>

#### 场景题

<details>
<summary>我想创建一个三层架构。你能逐步解释如何实现吗？</summary>

三层架构的实施步骤：

**1. 表示层（Web）：**

步骤 1：启动一个 Amazon EC2 实例作为 Web 服务器。该实例将托管您的网站或 Web 应用程序。
步骤 2：配置安全组以允许传入的 Web 流量（HTTP/HTTPS）到 Web 服务器。
步骤 3：可选择附加弹性 IP（EIP）以获得静态公共 IP 地址。

**2. 应用层（App）：**

步骤 4：启动另一个 EC2 实例作为应用服务器。该实例运行应用程序的业务逻辑。
步骤 5：配置安全组以允许来自 Web 服务器到应用服务器在必要端口上的传入流量。
步骤 6：安装和配置应用程序所需的任何中间件或应用程序软件。

**3. 数据层（Database）：**

步骤 7：为数据库层创建一个 Amazon RDS（关系数据库服务）实例或设置数据库服务器（例如，在 EC2 上）。
步骤 8：配置安全组以仅允许来自应用服务器的传入数据库连接。
步骤 9：创建数据库模式和表，并配置数据库访问和权限。
</details>

<details>
<summary>在具有私有和公有子网的 VPC 中，数据库服务器应该启动到哪个子网？</summary>

在同时具有私有和公有子网的 VPC 中，数据库服务器应该启动到**私有子网**中。将数据库服务器放在私有子网中可确保它们不能直接从互联网访问，从而增强安全性。公有子网通常用于需要从互联网访问的资源，如 Web 服务器。
</details>

<details>
<summary>EC2 的安全最佳实践有哪些？</summary>

EC2 的安全最佳实践：

- **使用安全组**：配置安全组以控制进出 EC2 实例的流量。只允许必要的端口和源。

- **使用密钥对**：使用密钥对（Linux 的 SSH 密钥或 Windows 的 RDP 密钥）而不是密码来验证对 EC2 实例的访问。

- **定期更新**：保持您的 EC2 实例及其软件使用安全补丁和更新保持最新。

- **使用 IAM 角色**：为 EC2 实例分配 IAM 角色以授予特定权限，减少在实例上存储访问密钥的需要。

- **启用监控**：使用 Amazon CloudWatch 监控性能并为异常活动或资源耗尽设置警报。

- **数据加密**：使用 Amazon EBS 加密等服务加密静态数据，使用 SSL/TLS 加密传输中的数据。

- **快照备份**：定期创建 EBS 快照和 AMI 来备份您的实例，确保在发生故障时能够恢复数据。

- **实例隔离**：在虚拟私有云（VPC）中将实例分离到公有和私有子网以实现网络隔离。

- **禁用根访问**：在 Linux 实例上禁用远程根登录，使用 sudo 用户执行管理任务。

- **IAM 策略**：使用细粒度的 IAM 策略根据最小权限原则限制访问。

- **使用堡垒主机**：如有必要，使用堡垒主机（跳转服务器）安全地访问私有实例。

- **监控访问**：监控和审计对 EC2 实例的访问，包括登录尝试和用户操作。

- **自动化安全**：实施 AWS Systems Manager 和 AWS Config 等自动化工具来强制执行安全策略。
</details>

<details>
<summary>我创建了一个具有自动扩展的 Web 应用程序。我观察到我的应用程序在周三和周五的上午 9 点到晚上 7 点之间流量最高。处理扩展的最佳解决方案是什么？</summary>

为了处理您的 Web 应用程序在周三和周五上午 9 点到晚上 7 点的高流量，您可以：

- **基于计划的自动扩展**：使用 AWS Auto Scaling 的计划扩展功能。设置一个计划，在周三和周五的高峰时段增加所需实例数量，在非高峰时段减少。

- **目标跟踪扩展策略**：基于 CPU 利用率或每个实例的请求数等指标创建目标跟踪扩展策略。设置目标以自动调整实例数量以维持特定的指标值。这有助于有效地处理流量波动。

通过结合这些方法，您的应用程序可以自动调整其容量以满足需求，确保在高峰时段扩展并在安静时段缩减，优化成本和性能。
</details>

<details>
<summary>我的 Amazon EC2 实例上运行着一个应用程序。一旦 CPU 利用率达到 100%，我想立即减少实例上的负载。你会怎么做？</summary>

要在 CPU 利用率达到 100% 时自动减少 Amazon EC2 实例上的负载，请按照以下步骤操作：

- **创建自动扩展组**：如果您还没有，请为您的 EC2 实例创建一个自动扩展组。

- **创建目标跟踪扩展策略**：在自动扩展组配置中，创建目标跟踪扩展策略。

- **选择 CPU 利用率作为指标**：选择 CPU 利用率作为要跟踪的指标。

- **设置目标值**：指定您要采取行动的目标 CPU 利用率水平，如 80% 或 90%，而不是 100%，以避免任何性能问题。AWS Auto Scaling 将自动调整实例数量以维持此目标值。

- **定义扩展操作**：为 CPU 利用率超过目标值时配置扩展操作。您可以根据需要指定增加或减少实例数量的操作。

- **应用策略**：将目标跟踪扩展策略应用到您的自动扩展组。
</details>

#### 其他

<details>
<summary>列举一些 Lambda 的托管运行时</summary>

AWS Lambda 支持的托管运行时包括：

**编译语言**：
- Java (Java 8, 11, 17)
- .NET Core (.NET Core 2.1, 3.1, .NET 6)
- Go (Go 1.x)
- Rust (通过自定义运行时)

**脚本语言**：
- Node.js (Node.js 12.x, 14.x, 16.x, 18.x)
- Python (Python 3.8, 3.9, 3.10, 3.11)
- Ruby (Ruby 2.7)

**其他**：
- PowerShell Core
- Docker 镜像（通过容器镜像支持）
</details>

### :small_blue_diamond: Azure 🌩️

<details>
<summary>什么是 Azure？</summary>

Azure 是 Microsoft 提供的云计算平台，提供超过 200 种云服务和产品，包括计算、存储、网络、数据库、分析、人工智能、机器学习、物联网等。Azure 让组织能够在云中构建、部署和管理应用程序，提供灵活、可扩展和安全的解决方案。
</details>

<details>
<summary>Azure 中的 ARM 模板是什么？</summary>

ARM（Azure Resource Manager）模板是 JSON 文件，定义了 Azure 解决方案的基础设施和配置。ARM 模板使用声明性语法，让您可以声明要部署的内容以及资源的配置方式，而不需要编写部署资源的编程命令序列。

主要优势：
- 基础设施即代码（IaC）
- 可重复部署
- 版本控制
- 参数化和模板重用
</details>

<details>
<summary>什么是 Azure CDN？</summary>

Azure CDN（内容分发网络）是用于向全球用户分发高带宽内容的全球解决方案。它通过将内容缓存在距离用户更近的战略位置来减少延迟和提高可用性。

主要功能：
- 静态内容缓存
- 动态站点加速
- DDoS 保护
- 自定义域名支持
- 实时分析报告
</details>

<details>
<summary>Azure App Service 和 Azure Functions 有什么区别？</summary>

**Azure App Service**：
- 用于托管 Web 应用程序、REST API 和移动后端
- 支持持续运行
- 适用于需要持久连接的应用
- 支持多种语言和框架

**Azure Functions**：
- 无服务器计算平台
- 事件驱动的代码执行
- 按需付费模式
- 适合短暂的任务和处理
</details>

<details>
<summary>如何使用 Azure CLI 在 Azure 上定义环境变量？</summary>

```bash
# 为 Web App 设置应用设置（环境变量）
az webapp config appsettings set \
  --resource-group <资源组名称> \
  --name <应用服务名称> \
  --settings MY_VARIABLE="my_value" ANOTHER_VAR="another_value"
```

或者使用应用服务配置：

```bash
# 使用应用服务配置
az webapp configuration appsettings set \
  -g <资源组名称> \
  -n <应用服务名称> \
  --setting-names "MY_VARIABLE=my_value" "ANOTHER_VAR=another_value"
```
</details>

<details>
<summary>如何在 Azure Blob Storage 和 Azure File Service 之间选择？</summary>

**Azure Blob Storage**：
- 适用于存储非结构化对象数据
- 适合大文件（如图像、视频、备份）
- 支持 blob 层级（热、冷、存档）
- REST API 访问
- 更适合 Web 内容分发

**Azure File Service**：
- 提供完全托管的文件共享
- 支持 SMB 协议
- 适合需要文件系统语义的应用
- 可以挂载为虚拟驱动器
- 更适合传统的应用程序
</details>

<details>
<summary>Azure Key Vault 中的 Keys 和 Secrets 有什么区别？</summary>

**Keys**：
- 用于加密操作的加密密钥
- 支持 RSA 和 ECC 密钥
- 可以用于加密、解密、签名和验证
- 密钥永远不会离开 Key Vault

**Secrets**：
- 存储小字符串值（如密码、连接字符串）
- 每个秘密最多 25KB
- 可以包含任意文本
- 不用于加密操作
</details>

<details>
<summary>Azure SQL Database 和 Azure SQL Managed Instance 有什么区别？</summary>

**Azure SQL Database**：
- 完全托管的平台即服务（PaaS）
- 单个数据库模型
- 更轻量级，更快
- 与其他 Azure 服务集成更好
- 适合新应用程序

**Azure SQL Managed Instance**：
- 更接近本地 SQL Server
- 支持多个数据库
- 提供更多 SQL Server 功能
- 更适合迁移现有应用程序
- 更大但延迟稍高
</details>

### :small_blue_diamond: Terraform 🏗️

<details>
<summary>什么是 IaC？什么是 Terraform？</summary>

**IaC（基础设施即代码）**：
- 使用代码来管理和配置基础设施的方法
- 允许版本控制、自动化和重复部署
- 提高一致性和可重复性

**Terraform**：
- 开源的基础设施即代码工具
- 由 HashiCorp 开发
- 使用 HCL（HashiCorp 配置语言）
- 支持多个云提供商
- 基于声明式方法
</details>

<details>
<summary>什么是 Terraform 状态？</summary>

Terraform 状态文件记录了 Terraform 管理的基础设施的当前状态。它是一个 JSON 文件，包含：

- 资源配置和属性
- 资源之间的依赖关系
- 元数据和版本信息

状态文件对于 Terraform 的正常运行至关重要，应该：
- 安全存储（使用远程后端）
- 版本控制
- 定期备份
</details>

<details>
<summary>最常见的 Terraform 命令有哪些？</summary>

```bash
# 初始化工作目录
terraform init

# 预览将要应用的更改
terraform plan

# 应用配置更改
terraform apply

# 销毁基础设施
terraform destroy

# 格式化配置文件
terraform fmt

# 验证配置语法
terraform validate

# 导入现有资源
terraform import

# 输出变量值
terraform output

# 刷新状态文件
terraform refresh
```
</details>

<details>
<summary>什么是 Terraform 后端？</summary>

Terraform 后端定义了如何存储和加载状态文件。主要功能：

- 状态存储：远程存储状态文件
- 状态锁定：防止并发修改
- 远程操作：在远程执行 Terraform 操作

常用后端：
- **S3**：AWS 简单存储服务
- **Azure Blob Storage**：Azure 的对象存储
- **Google Cloud Storage**：Google 的对象存储
- **Terraform Cloud**：HashiCorp 的托管服务
</details>

<details>
<summary>Terraform 中的模块是什么？</summary>

模块是 Terraform 配置的可重用组件，允许您：

- 封装和重用基础设施模式
- 简化复杂配置
- 标准化部署实践
- 促进团队协作

模块结构：
```
modules/
  ├── main.tf      # 主要资源
  ├── variables.tf # 输入变量
  ├── outputs.tf   # 输出值
  └── README.md    # 文档
```
</details>

### :small_blue_diamond: Ansible 🔧

<details>
<summary>什么是 Ansible？</summary>

Ansible 是一个开源的自动化工具，用于配置管理、应用程序部署、任务自动化和 IT 编排。它使用简单的 YAML 语言（称为 Playbook）来描述自动化任务，通过 SSH 协议与目标系统通信，无需在目标系统上安装代理。
</details>

<details>
<summary>Ansible 是如何工作的？</summary>

Ansible 的工作原理：

1. **控制节点**：运行 Ansible 的机器
2. **清单文件**：定义要管理的目标主机
3. **Playbook**：YAML 格式的自动化任务定义
4. **模块**：执行具体任务的代码单元
5. **连接**：通过 SSH 连接到目标主机执行任务

流程：控制节点 → 解析 Playbook → 连接目标 → 执行模块 → 返回结果
</details>

<details>
<summary>什么是 Ansible Galaxy？</summary>

Ansible Galaxy 是 Ansible 的官方角色和集合共享平台。它允许用户：

- 分享和下载可重用的角色
- 查找由社区创建的内容
- 管理依赖关系
- 简化复杂 Playbook 的组织

使用命令：`ansible-galaxy install username.rolename`
</details>

<details>
<summary>什么是 Ansible handlers？</summary>

Handlers 是特殊的任务，只有在被 notify 时才会执行。通常用于重启服务等操作，只有当配置发生变化时才触发。

特点：
- 只在任务发生变化时执行
- 在所有任务执行完成后运行
- 一次 playbook 运行只执行一次
- 适合重启服务、重新加载配置等操作

示例：
```yaml
- name: Update nginx config
  template: src=nginx.conf dest=/etc/nginx/nginx.conf
  notify: restart nginx

handlers:
  - name: restart nginx
    service: name=nginx state=restarted
```
</details>

<details>
<summary>什么是 Ansible Vault？</summary>

Ansible Vault 是 Ansible 的加密功能，用于保护敏感数据，如密码、API 密钥等。

功能：
- 加密变量文件
- 加密单个变量
- 支持多种加密方式
- 可以在 playbook 中直接使用加密数据

常用命令：
```bash
ansible-vault create file.yml    # 创建加密文件
ansible-vault edit file.yml     # 编辑加密文件
ansible-vault decrypt file.yml  # 解密文件
ansible-vault encrypt file.yml  # 加密文件
```
</details>

<details>
<summary>什么是 Ansible collections？</summary>

Collections 是 Ansible 的新内容分发格式，将 playbooks、roles、modules 和插件打包在一起。

优点：
- 更好的内容组织
- 版本控制
- 依赖管理
- 支持多种内容类型

结构：
```
collection/
├── plugins/
│   ├── modules/
│   ├── inventory/
│   └── lookup/
├── roles/
├── playbooks/
└── tests/
```
</details>

<details>
<summary>如何获取 Ansible 预定义变量列表？</summary>

使用 `setup` 模块收集事实信息：

```bash
# 收集所有事实
ansible all -m setup

# 收集特定事实
ansible all -m setup -a 'filter=ansible_os_family'

# 使用 ansible_facts 变量
{{ ansible_facts['hostname'] }}
{{ ansible_facts['os_family'] }}
```
</details>

<details>
<summary>Ansible playbook 和 ad-hoc 命令有什么区别？</summary>

**Ad-hoc 命令**：
- 一次性执行简单任务
- 不保存为文件
- 适合快速测试和简单操作
- 语法：`ansible <hosts> -m <module> -a "<args>"`

**Playbook**：
- 保存为 YAML 文件
- 可以描述复杂的工作流
- 支持条件、循环、变量
- 可重用和版本控制
- 适合复杂的自动化任务
</details>

<details>
<summary>Ansible 使用什么协议与客户端系统通信？</summary>

Ansible 主要使用 **SSH（Secure Shell）** 协议与 Linux/Unix 系统通信，使用 **WinRM** 与 Windows 系统通信。

特点：
- 无需在目标系统安装代理
- 使用现有的认证机制（密钥、密码）
- 支持sudo权限提升
- 并行执行
</details>

<details>
<summary>什么是清单文件？</summary>

清单（Inventory）文件定义了 Ansible 要管理的主机列表。支持多种格式：

**INI 格式**：
```ini
[webservers]
web1.example.com
web2.example.com

[databases]
db1.example.com
```

**YAML 格式**：
```yaml
all:
  children:
    webservers:
      hosts:
        web1.example.com:
        web2.example.com:
    databases:
      hosts:
        db1.example.com:
```
</details>

### :small_blue_diamond: CI/CD 🛠️

<details>
<summary>什么是持续集成？</summary>

持续集成（Continuous Integration，CI）是一种软件开发实践，要求开发人员频繁地将代码集成到共享仓库中。每次集成都通过自动构建和自动测试来验证。

主要实践：
- 频繁提交代码
- 自动化构建
- 自动化测试
- 快速反馈
- 保持代码库可工作
</details>

<details>
<summary>解释蓝绿部署</summary>

蓝绿部署是一种发布策略，通过维护两个相同的生产环境来实现零停机部署。

流程：
1. 当前版本在蓝色环境运行
2. 部署新版本到绿色环境
3. 测试绿色环境
4. 切换流量到绿色环境
5. 保留蓝色环境作为备份

优点：
- 零停机时间
- 即时回滚
- 降低风险
</details>

<details>
<summary>什么是 CI/CD 流水线？</summary>

CI/CD 流水线是自动化软件交付的流程，从代码提交到生产部署。

阶段：
1. **源码阶段**：获取代码
2. **构建阶段**：编译和打包
3. **测试阶段**：运行自动化测试
4. **部署阶段**：部署到环境
5. **验证阶段**：验证部署结果

工具：Jenkins、GitLab CI、GitHub Actions、Azure DevOps
</details>

<details>
<summary>什么是金丝雀部署？</summary>

金丝雀部署是一种渐进式部署策略，将新版本逐步发布给一小部分用户，验证后再全面发布。

流程：
1. 部署新版本到小部分服务器
2. 将少量用户流量导向新版本
3. 监控指标和错误率
4. 逐步增加流量比例
5. 完全切换到新版本

优点：
- 降低风险
- 真实用户验证
- 渐进式发布
</details>

<details>
<summary>什么是滚动部署？</summary>

滚动部署是一种更新策略，逐步替换旧版本实例，而不需要停止整个服务。

流程：
1. 逐个或分批更新实例
2. 将流量从更新中的实例移开
3. 部署新版本
4. 验证新实例
5. 将流量导回
6. 重复直到所有实例更新

优点：
- 服务始终可用
- 资源利用率高
- 风险较低
</details>

### :small_blue_diamond: DevOps 方法论、实践和敏捷

<details>
<summary>DevOps 的优势是什么？</summary>

DevOps 的主要优势：

1. **加速交付**：
   - 更快的发布周期
   - 自动化部署
   - 快速反馈

2. **提高质量**：
   - 持续测试
   - 早期发现问题
   - 减少缺陷

3. **增强可靠性**：
   - 自动化恢复
   - 监控和告警
   - 事件响应

4. **改善协作**：
   - 打破部门壁垒
   - 共享责任
   - 文化转变

5. **安全性**：
   - DevSecOps 集成
   - 自动化安全扫描
   - 合规自动化
</details>

<details>
<summary>你能描述一些你使用过的分支策略吗？</summary>

常见的分支策略：

**Git Flow**：
- master：生产代码
- develop：开发代码
- feature/*：功能分支
- release/*：发布分支
- hotfix/*：热修复分支

**GitHub Flow**：
- master：生产代码
- feature/*：功能分支
- 直接合并到 master

**GitLab Flow**：
- master：生产代码
- develop：开发代码
- feature/*：功能分支
- 环境分支：production、staging

**Trunk-Based Development**：
- 所有开发在主分支
- 短期功能分支
- 持续集成
</details>

### :small_blue_diamond: Docker & K8s 🐳 🎻

#### 容器（Docker）

<details>
<summary>什么是 Docker？它是如何工作的？</summary>

Docker 是一个软件平台，允许您使用容器快速构建、测试和部署应用程序。容器允许开发者将应用程序及其所需的所有部分（如库和其他依赖项）打包，并作为一个包发布。

Docker 的工作原理：
1. 使用 Dockerfile 定义应用程序环境
2. 构建镜像（image）
3. 运行容器（container）
4. 容器共享主机内核，但相互隔离
</details>

<details>
<summary>什么是容器？它的基本原理是什么？</summary>

容器是软件包，包含在任何环境中运行所需的所有必要元素。通过这种方式，容器虚拟化操作系统并可以在任何地方运行，从私有数据中心到公共云，甚至在开发者的个人机器上。

容器的基本原理：
- **进程隔离**：使用 Linux 命名空间隔离进程
- **资源限制**：使用 cgroups 限制资源使用
- **文件系统隔离**：每个容器有独立的文件系统视图
- **网络隔离**：每个容器有独立的网络栈
</details>

<details>
<summary>Linux 中的 cgroups 和 namespaces 是什么？</summary>

**控制组（cgroups）**：
cgroups 允许管理员在系统上运行的用户定义任务组（进程）之间分配资源——如 CPU 时间、系统内存、网络带宽或这些资源的组合。

**命名空间（namespaces）**：
命名空间将全局系统资源包装在抽象中，使得命名空间内的进程看起来它们拥有自己隔离的全局资源实例。对全局资源的更改对命名空间的其他成员进程可见，但对其他进程不可见。命名空间的一种用途是实现容器。
</details>

<details>
<summary>Dockerfile 的基本组件有哪些？</summary>

Dockerfile 的主要指令：

- **FROM**：指定基础镜像
- **COPY**：从主机复制文件到容器
- **ADD**：类似于 COPY，但支持 URL 和自动解压
- **RUN**：在容器中执行命令
- **CMD**：容器启动时执行的默认命令
- **ENTRYPOINT**：配置容器启动时执行的命令
- **WORKDIR**：设置工作目录
- **EXPOSE**：声明容器监听的端口
- **ENV**：设置环境变量
</details>

<details>
<summary>容器和虚拟机有什么区别？</summary>

**容器**：
- 共享主机操作系统内核
- 启动速度快（秒级）
- 轻量级，资源占用少
- 进程级别的隔离

**虚拟机**：
- 有独立的操作系统
- 启动速度慢（分钟级）
- 重量级，资源占用多
- 硬件级别的隔离
</details>

<details>
<summary>COPY 和 ADD 命令有什么区别？</summary>

**COPY**：
- 只能从本地复制文件
- 简单直接
- 更推荐使用

**ADD**：
- 可以从 URL 下载文件
- 自动解压压缩文件
- 功能更强大但更复杂
</details>

<details>
<summary>CMD 和 ENTRYPOINT 有什么区别？</summary>

**CMD**：
- 提供默认命令和参数
- 可以被 docker run 的参数覆盖
- 可以有多个，但只有最后一个生效

**ENTRYPOINT**：
- 配置容器启动时运行的命令
- 不会被 docker run 的参数覆盖
- 适合固定命令，参数通过 CMD 提供
</details>

<details>
<summary>什么是 Docker Compose？什么时候使用？</summary>

Docker Compose 是用于定义和运行多容器 Docker 应用程序的工具。通过 YAML 文件配置应用程序的服务，然后使用单个命令创建和启动所有服务。

使用场景：
- 本地开发环境
- 多服务应用部署
- 微服务架构测试
- CI/CD 流水线
</details>

#### 容器编排（Kubernetes = K8s）

<details>
<summary>什么是 Kubernetes？</summary>

Kubernetes（K8s）是一个开源的容器编排平台，用于自动化容器化应用程序的部署、扩展和管理。它提供了一个可移植、可扩展的容器运行环境。

主要功能：
- 自动化部署和回滚
- 服务发现和负载均衡
- 自动装箱（资源调度）
- 自我修复
- 密钥和配置管理
- 存储编排
</details>

<details>
<summary>Kubernetes 解决了什么问题？</summary>

Kubernetes 解决了容器化应用程序在生产环境中面临的主要挑战：

1. **服务发现**：自动发现和路由流量
2. **弹性伸缩**：根据负载自动调整实例数量
3. **故障恢复**：自动重启失败的容器
4. **滚动更新**：零停机部署新版本
5. **配置管理**：统一管理应用配置
6. **资源管理**：优化资源利用率
7. **多环境部署**：支持混合云和多云部署
</details>

<details>
<summary>Docker 和 Kubernetes 有什么区别？</summary>

**Docker**：
- 容器运行时
- 创建和管理单个容器
- 适合开发和测试

**Kubernetes**：
- 容器编排平台
- 管理多个容器的集群
- 适合生产环境
- 可以使用 Docker 作为容器运行时
</details>

<details>
<summary>什么是 Pod？它有什么作用？</summary>

Pod 是 Kubernetes 中最小的可部署单元，可以包含一个或多个容器。

Pod 的特点：
- 共享网络命名空间
- 共享存储卷
- 容器间通过 localhost 通信
- 作为部署、扩展的基本单元
</details>

<details>
<summary>什么是 Deployment？</summary>

Deployment 是 Kubernetes 中用于管理 Pod 和 ReplicaSet 的控制器。

功能：
- 声明式应用管理
- 滚动更新
- 回滚到先前版本
- 扩容和缩容
- 自我修复
</details>

<details>
<summary>什么是 Service？</summary>

Service 为一组功能相同的 Pod 提供统一的访问入口。

类型：
- **ClusterIP**：集群内部访问
- **NodePort**：通过节点端口暴露
- **LoadBalancer**：使用外部负载均衡器
- **ExternalName**：映射到外部服务
</details>

<details>
<summary>什么是 Ingress？</summary>

Ingress 是管理外部访问到集群内服务的 API 对象，提供 HTTP 和 HTTPS 路由。

功能：
- 基于主机名和路径的路由
- TLS 终止
- 负载均衡
- 会话亲和性
</details>

## 系统设计 🍥

### :small_blue_diamond: CDN & 缓存

<details>
<summary>什么是 CDN？为什么要使用它？</summary>

CDN（内容分发网络）是分布在全球各地的服务器网络，用于缓存和分发内容。

使用 CDN 的好处：
- 减少延迟：内容离用户更近
- 提高性能：缓存静态资源
- 降低带宽成本：减少源服务器负载
- 提高可用性：多个节点冗余
- DDoS 防护：分散攻击流量
</details>

<details>
<summary>CAD 定理是什么？</summary>

CAP 定理指出，分布式系统不能同时满足以下三个保证：

- **一致性（Consistency）**：所有节点同时看到相同的数据
- **可用性（Availability）**：系统保证每个请求都会收到响应
- **分区容错性（Partition Tolerance）**：系统在网络分区的情况下继续运行

系统只能在 C 和 A 之间选择一个，P 是必须的。
</details>

<details>
<summary>水平扩展和垂直扩展有什么区别？</summary>

**水平扩展（横向扩展）**：
- 增加更多服务器
- 分散负载
- 更好的容错性
- 通常更复杂

**垂直扩展（纵向扩展）**：
- 增强单个服务器性能
- 更简单
- 有物理限制
- 单点故障风险
</details>

<details>
<summary>正向代理和反向代理有什么区别？</summary>

**正向代理**：
- 代表客户端发出请求
- 隐藏客户端身份
- 客户端配置使用

**反向代理**：
- 代表服务器接收请求
- 隐藏服务器身份
- 服务器端配置
- 提供负载均衡
</details>

<details>
<summary>什么是负载均衡？它是如何工作的？</summary>

负载均衡是将工作负载分配到多个计算资源的过程，以优化资源使用、最大化吞吐量、最小化响应时间并避免过载。

工作原理：
1. 接收客户端请求
2. 根据算法选择后端服务器
3. 转发请求
4. 返回响应给客户端

常见算法：
- 轮询（Round Robin）
- 加权轮询
- 最少连接
- IP Hash
</details>

### :small_blue_diamond: API 设计

<details>
<summary>什么是 REST？</summary>

REST（表述性状态转移）是一种软件架构风格，定义了一组约束和属性，用于创建可扩展的 Web 服务。

REST 的约束：
- 客户端-服务器架构
- 无状态
- 可缓存
- 统一接口
- 分层系统
- 按需代码
</details>

<details>
<summary>什么是 RESTful API？</summary>

RESTful API 是遵循 REST 架构风格的 Web API。

特征：
- 使用 HTTP 方法（GET、POST、PUT、DELETE）
- 使用资源标识符（URL）
- 无状态通信
- 支持多种数据格式（JSON、XML）
- 标准的 HTTP 状态码
</details>

<details>
<summary>HTTP 方法的正确使用</summary>

- **GET**：获取资源（安全、幂等）
- **POST**：创建资源
- **PUT**：完整更新资源（幂等）
- **PATCH**：部分更新资源
- **DELETE**：删除资源（幂等）
</details>

<details>
<summary>常见的 HTTP 状态码</summary>

**2xx 成功**：
- 200：成功
- 201：已创建
- 204：无内容

**3xx 重定向**：
- 301：永久移动
- 302：临时移动

**4xx 客户端错误**：
- 400：错误请求
- 401：未授权
- 403：禁止
- 404：未找到
- 410：已删除

**5xx 服务器错误**：
- 500：内部服务器错误
- 503：服务不可用
</details>

<details>
<summary>RESTful API 设计最佳实践</summary>

1. **使用名词而非动词**：`/users` 而不是 `/getUsers`
2. **使用复数形式**：`/users` 而不是 `/user`
3. **使用正确的 HTTP 方法**
4. **版本控制**：`/api/v1/users`
5. **分页**：`?page=1&limit=20`
6. **过滤和排序**：`?sort=name&order=asc`
7. **嵌套资源**：`/users/123/posts`
8. **错误处理**：返回清晰的错误信息
9. **使用 HTTPS**
10. **文档化**：提供 API 文档
</details>

### :small_blue_diamond: 数据库

<details>
<summary>关系型数据库和非关系型数据库的优缺点</summary>

**关系型数据库（SQL）**：
优点：
- ACID 事务支持
- 数据一致性
- 复杂查询能力
- 成熟的工具和生态系统

缺点：
- 扩展性有限
- 固定的模式
- 性能瓶颈

**非关系型数据库（NoSQL）**：
优点：
- 高扩展性
- 灵活的模式
- 高性能
- 适合大数据

缺点：
- 最终一致性
- 事务支持有限
- 查询功能相对简单
</details>

<details>
<summary>什么是数据库索引？如何提高查询性能？</summary>

索引是提高数据库查询性能的数据结构，类似于书的目录。

索引类型：
- **主键索引**：唯一标识
- **唯一索引**：保证列值唯一
- **复合索引**：多列组合
- **全文索引**：文本搜索

最佳实践：
- 为经常查询的列创建索引
- 避免过多索引（影响写入性能）
- 使用复合索引优化多列查询
- 定期分析和优化索引
</details>

<details>
<summary>什么是数据库复制？</summary>

数据库复制是将数据从一个数据库复制到一个或多个数据库的过程。

复制类型：
- **主从复制**：一个主库，多个从库
- **主主复制**：多个主库，互相复制

复制模式：
- **同步复制**：强一致性，性能较低
- **异步复制**：最终一致性，性能较高
- **半同步复制**：折中方案
</details>

<details>
<summary>什么是数据库分片？</summary>

分片是将大型数据库拆分成多个较小数据库（分片）的过程。

分片策略：
- **水平分片**：按行拆分
- **垂直分片**：按列拆分
- **功能分片**：按功能模块拆分

优点：
- 提高性能
- 增加容量
- 提高可用性

缺点：
- 复杂性增加
- 跨分片查询困难
- 数据分布挑战
</details>

## 软件工程

### :small_blue_diamond: 通用

<details>
<summary>API 版本控制有哪些方式？</summary>

常见的 API 版本控制方法：

1. **URL 路径版本控制**：
   - `/api/v1/users`
   - `/api/v2/users`

2. **查询参数版本控制**：
   - `/api/users?version=1`
   - `/api/users?v=2`

3. **HTTP 头版本控制**：
   - `Accept: application/vnd.api.v1+json`
   - `API-Version: v1`

4. **子域名版本控制**：
   - `v1.api.example.com/users`
   - `v2.api.example.com/users`
</details>

<details>
<summary>什么是 API 的幂等性？</summary>

幂等性是指对同一个 API 进行多次请求，应该产生与单次请求相同的结果。

幂等的 HTTP 方法：
- **GET**：获取资源（总是幂等）
- **PUT**：完整更新资源（幂等）
- **DELETE**：删除资源（幂等）
- **PATCH**：部分更新资源（可能不幂等）
- **POST**：创建资源（不幂等）
</details>

<details>
<summary>如何在 API 中实现身份验证？</summary>

常见的 API 身份验证方法：

1. **API Key**：
   - 简单但安全性较低
   - 在请求头或参数中传递

2. **OAuth 2.0**：
   - 标准化的授权框架
   - 适合第三方应用访问

3. **JWT (JSON Web Tokens)**：
   - 无状态身份验证
   - 包含用户信息和权限

4. **Basic Authentication**：
   - Base64 编码的用户名:密码
   - 适合内部 API

5. **HMAC (Hash-based Message Authentication Code)**：
   - 使用密钥验证请求完整性
   - 高安全性
</details>

<details>
<summary>什么是熔断器？它有什么好处？</summary>

熔断器是一种模式，用于防止级联故障，提高系统的弹性。

工作原理：
1. **关闭状态**：正常请求
2. **打开状态**：直接返回错误，不请求后端
3. **半开状态**：尝试部分请求

好处：
- 防止级联故障
- 快速失败
- 自动恢复
- 提高系统稳定性
</details>

<details>
<summary>什么是竞态条件？</summary>

竞态条件是指两个或多个进程或线程访问共享数据时，最终结果取决于它们执行顺序的情况。

示例：
- 两个线程同时读取和修改同一个变量
- 并发更新库存数量
- 银行账户余额的并发更新

解决方案：
- 互斥锁（Mutex）
- 信号量（Semaphore）
- 原子操作
- 乐观并发控制
</details>

### :small_blue_diamond: Golang

<details>
<summary>什么是 Go？它为什么被创建？</summary>

Go（Golang）是 Google 开发的开源编程语言。

创建原因：
- 简化编程语言
- 提高编译速度
- 高效的并发支持
- 简化的依赖管理
- 适合大规模软件工程

特点：
- 静态类型
- 垃圾回收
- 内置并发支持
- 简洁的语法
- 快速编译
</details>

<details>
<summary>什么是 Goroutine？</summary>

Goroutine 是 Go 语言中的轻量级线程，由 Go 运行时管理。

特点：
- 轻量级（几 KB 的栈）
- 由 Go 调度器管理
- 通过通道通信
- 低成本创建

示例：
```go
go func() {
    fmt.Println("Hello from goroutine")
}()
```
</details>

<details>
<summary>什么是通道（Channel）？</summary>

通道是 Goroutine 之间通信的主要方式，实现"不要通过共享内存来通信，而是通过通信来共享内存"。

类型：
- **无缓冲通道**：同步通信
- **有缓冲通道**：异步通信

示例：
```go
ch := make(chan int)  // 无缓冲
ch := make(chan int, 10)  // 有缓冲

ch <- 42  // 发送
value := <-ch  // 接收
```
</details>

<details>
<summary>Go 有异常吗？如何处理错误？</summary>

Go 没有传统的异常机制，使用多返回值处理错误。

错误处理模式：
```go
value, err := someFunction()
if err != nil {
    // 处理错误
    log.Fatal(err)
}
```

Panic 和 Recover：
- panic：严重错误，程序终止
- recover：捕获 panic
</details>

<details>
<summary>Go 中的指针是什么？</summary>

指针存储变量的内存地址。

作用：
- 直接修改原始值
- 避免值拷贝
- 实现引用传递

示例：
```go
var x int = 10
var p *int = &x  // p 指向 x
fmt.Println(*p)  // 输出 10
*p = 20  // 修改 x 的值
```
</details>

### :small_blue_diamond: Python

<details>
<summary>什么是 Python？它有什么特点？</summary>

Python 是一种解释型、高级和通用的编程语言。由 Guido van Rossum 于 1991 年创建。

特点：
- 简洁易读的语法
- 动态类型
- 解释执行
- 面向对象编程
- 丰富的标准库
- 跨平台
</details>

<details>
<summary>什么是 Python 的 GIL？</summary>

GIL（全局解释器锁）是 Python 解释器中的一个互斥锁，它保护对 Python 对象的访问，防止多个原生线程同时执行 Python 字节码。

影响：
- 限制了多线程的并行执行
- CPU 密集型任务不适合多线程
- I/O 密集型任务仍可受益于多线程

解决方案：
- 使用多进程（multiprocessing）
- 使用异步编程（asyncio）
- 使用其他 Python 实现（如 Jython）
</details>

<details>
<summary>Python 中的装饰器是什么？</summary>

装饰器是 Python 中的一个设计模式，允许在不修改函数或类源代码的情况下扩展其功能。

示例：
```python
# 装饰器定义
def my_decorator(func):
    def wrapper():
        print("Something is happening before the function is called.")
        func()
        print("Something is happening after the function is called.")
    return wrapper

# 使用装饰器
@my_decorator
def say_hello():
    print("Hello!")

say_hello()
```
</details>

<details>
<summary>什么是 Python 的生成器？</summary>

生成器是一种特殊的迭代器，使用 `yield` 关键字而不是 `return` 来返回值。

优点：
- 内存高效
- 惰性计算
- 适用于处理大数据集

示例：
```python
def fibonacci_generator():
    a, b = 0, 1
    while True:
        yield a
        a, b = b, a + b

fib = fibonacci_generator()
for i in range(10):
    print(next(fib))
```
</details>

<details>
<summary>Python 中的 *args 和 **kwargs 是什么？</summary>

- **`*args`**：用于传递非关键字可变参数
- **`**kwargs`**：用于传递关键字可变参数

示例：
```python
def func(*args, **kwargs):
    print("args:", args)
    print("kwargs:", kwargs)

func(1, 2, 3, name="John", age=30)
# 输出：
# args: (1, 2, 3)
# kwargs: {'name': 'John', 'age': 30}
```
</details>

<details>
<summary>Python 的列表推导式是什么？</summary>

列表推导式是创建列表的简洁语法。

示例：
```python
# 传统方式
squares = []
for x in range(10):
    squares.append(x ** 2)

# 列表推导式
squares = [x ** 2 for x in range(10)]

# 带条件的列表推导式
even_squares = [x ** 2 for x in range(10) if x % 2 == 0]
```
</details>

<details>
<summary>什么是 Python 的虚拟环境？</summary>

虚拟环境是 Python 环境的独立副本，用于：
- 隔离项目依赖
- 避免版本冲突
- 保持系统 Python 清洁

创建和使用：
```bash
# 创建虚拟环境
python -m venv myenv

# 激活虚拟环境
source myenv/bin/activate  # Linux/Mac
myenv\Scripts\activate      # Windows

# 退出虚拟环境
deactivate
```
</details>

### :small_blue_diamond: Java

- 什么是 JVM？
- 什么是 JRE？
- 什么是 JDK？
- JDK 和 JRE 有什么区别？
- JVM 和 JRE 有什么区别？
- Java 中的 HashMap 是如何工作的？
- 接口和抽象类有什么区别？
- Java 中的垃圾回收是如何工作的？
- 垃圾回收如何防止 Java 应用程序内存溢出？
- 栈和堆有什么区别？
- 什么是死锁？
- ArrayList 和 LinkedList 有什么区别？
- Java 支持多重继承吗？
- == 和 .equals() 有什么区别？
- 解释序列化和反序列化？

### :small_blue_diamond: JavaScript (TS, Node.js...)

- 什么是 TypeScript？
- TypeScript 和 JavaScript 有什么区别？
- 为什么要使用 TypeScript？
- TypeScript 有哪些优势？
- TypeScript 中的类型是什么？
- TypeScript 中的类型断言是什么？
- 什么是基本数据类型？
- TypeScript 中的特殊数据类型是什么？
- TypeScript 中的接口是什么？
- 接口 vs 类型？

## Data

### 数据建模和模式

<details>
<summary>什么是数据建模？实施数据模型有什么好处？</summary>

数据建模是创建整个信息系统或其部分的可视化表示，以传达数据之间连接的过程。数据建模概念为组织中数据的组织和管理创建了一个蓝图。数据模型为开发人员和非技术利益相关者提供了一种简化的方式，可以进行关于业务需求的有意义的对话，以及数据洞察如何推动更好的决策。
</details>

<details>
<summary>执行数据建模时使用哪些设计模式？</summary>

常见的数据建模模式：

- **星型模式（Star Schema）**：
  - 中心事实表 + 维度表
  - 简单、高效
  - 适合数据仓库

- **雪花模式（Snowflake Schema）**：
  - 规范化的维度表
  - 减少数据冗余
  - 查询较复杂

- **星系模式（Galaxy Schema）**：
  - 多个事实表
  - 共享维度表
  - 复杂业务场景
</details>

## Machine Learning

## Cyber Security & Info Security

<details>
<summary>什么是防火墙？它是如何工作的？</summary>

防火墙是网络安全设备，根据预定的安全规则监控和控制传入和传出的网络流量。它可以是硬件、软件或两者的组合，旨在防止对网络的未经授权的访问，同时允许合法流量通过。防火墙通常通过分析数据包并根据网络管理员建立的规则允许或阻止它们来工作。
</details>

<details>
<summary>什么是 DDoS 攻击？它是如何工作的？</summary>

DDoS（分布式拒绝服务）攻击是一种网络攻击，涉及用来自多个源的流量淹没目标系统或网络，以使其过载并对合法用户不可用。DDoS 攻击可以使用多种技术进行，包括僵尸网络、放大攻击和 SYN 洪水。
</details>

<details>
<summary>什么是钓鱼攻击？如何识别和防范？</summary>

钓鱼攻击是一种网络诈骗，攻击者伪装成可信实体，通过电子邮件、短信或网站诱骗受害者提供敏感信息，如密码、信用卡号或个人数据。

识别方法：
- 检查发件人地址
- 注意语法错误
- 验证网站 URL
- 警惕紧急请求

防范措施：
- 使用邮件过滤
- 启用双因素认证
- 定期更新软件
- 员工安全培训
</details>

<details>
<summary>CIA 三元组是什么？为什么在网络安全中很重要？</summary>

CIA 三元组代表机密性（Confidentiality）、完整性（Integrity）和可用性（Availability）。它是网络安全中的一个基本概念，指的是保护敏感信息的三个关键目标：维护其机密性、确保其完整性，并保证其对授权用户的可用性。

**机密性**：防止未经授权的信息泄露
**完整性**：防止未经授权的数据修改
**可用性**：确保授权用户可以访问信息
</details>

## Interpersonal & behavioural questions

## References: